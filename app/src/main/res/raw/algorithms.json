[
  {
    "id": "sort-bubble",
    "topic": "Bubble Sort",
    "category": "Sorting",
    "description": "Simple comparison-based sorting, swapping adjacent out-of-order elements.",
    "time_complexity": { "best": "O(n)", "average": "O(n²)", "worst": "O(n²)" },
    "space_complexity": "O(1)",
    "stable": true,
    "in_place": true,
    "pseudo_code": "for i = 0..n-1:\n  swapped = false\n  for j = 0..n-i-2:\n    if a[j] > a[j+1]: swap(a[j], a[j+1]); swapped = true\n  if not swapped: break",
    "visualization": {
      "type": "step_by_step",
      "description": "Bars represent array values. Highlights comparisons (red) and swaps (orange). Largest values bubble to end.",
      "example_steps": [
        "Initial: [5,1,4,2,8]",
        "Compare 5↔1 (swap): [1,5,4,2,8]",
        "Compare 5↔4 (swap): [1,4,5,2,8]",
        "Compare 5↔2 (swap): [1,4,2,5,8]",
        "Compare 5↔8 (no swap): [1,4,2,5,8]",
        "Pass complete; 8 sorted"
      ]
    },
    "code": {
      "python": "def bubbleSort(nums):\n    n = len(nums)\n    for i in range(n):\n        swapped = False\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                swapped = True\n        if not swapped:\n            break\n    return nums",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    void bubbleSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            bool swapped = false;\n            for (int j = 0; j < n - i - 1; j++) {\n                if (nums[j] > nums[j + 1]) {\n                    swap(nums[j], nums[j + 1]);\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    public void bubbleSort(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            boolean swapped = false;\n            for (int j = 0; j < n - i - 1; j++) {\n                if (nums[j] > nums[j + 1]) {\n                    int temp = nums[j];\n                    nums[j] = nums[j + 1];\n                    nums[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n    }\n}",
      "javascript": "function bubbleSort(nums) {\n    const n = nums.length;\n    for (let i = 0; i < n; i++) {\n        let swapped = false;\n        for (let j = 0; j < n - i - 1; j++) {\n            if (nums[j] > nums[j + 1]) {\n                [nums[j], nums[j + 1]] = [nums[j + 1], nums[j]];\n                swapped = true;\n            }\n        }\n        if (!swapped) {\n            break;\n        }\n    }\n    return nums;\n}",
      "rust": "impl Solution {\n    pub fn bubble_sort(nums: &mut Vec<i32>) {\n        let n = nums.len();\n        for i in 0..n {\n            let mut swapped = false;\n            for j in 0..(n - i - 1) {\n                if nums[j] > nums[j + 1] {\n                    nums.swap(j, j + 1);\n                    swapped = true;\n                }\n            }\n            if !swapped {\n                break;\n            }\n        }\n    }\n}",
      "kotlin": "class Solution {\n    fun bubbleSort(nums: MutableList<Int>) {\n        val n = nums.size\n        for (i in 0 until n) {\n            var swapped = false\n            for (j in 0 until n - i - 1) {\n                if (nums[j] > nums[j + 1]) {\n                    val temp = nums[j]\n                    nums[j] = nums[j + 1]\n                    nums[j + 1] = temp\n                    swapped = true\n                }\n            }\n            if (!swapped) {\n                break\n            }\n        }\n    }\n}"
    },
    "tags": ["basic","comparison","in-place","stable"]
  },
  {
    "id": "sort-selection",
    "topic": "Selection Sort",
    "category": "Sorting",
    "description": "Selects the minimum each pass and swaps it with the front.",
    "time_complexity": { "best": "O(n²)", "average": "O(n²)", "worst": "O(n²)" },
    "space_complexity": "O(1)",
    "stable": false,
    "in_place": true,
    "pseudo_code": "for i = 0..n-2:\n  min = i\n  for j = i+1..n-1: if a[j] < a[min]: min = j\n  swap(a[i], a[min])",
    "visualization": {
      "type": "step_by_step",
      "description": "Highlights current minimum (blue) and swap (orange) per pass.",
      "example_steps": [
        "Initial: [64,25,12,22,11]",
        "Pass1: min=11; swap with 64 → [11,25,12,22,64]",
        "Pass2: min=12; swap → [11,12,25,22,64]",
        "…",
        "Final: [11,12,22,25,64]"
      ]
    },
    "code": {
      "python": "def selectionSort(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        minIndex = i\n        for j in range(i + 1, n):\n            if nums[j] < nums[minIndex]:\n                minIndex = j\n        nums[i], nums[minIndex] = nums[minIndex], nums[i]\n    return nums",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    void selectionSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] < nums[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            swap(nums[i], nums[minIndex]);\n        }\n    }\n};",
      "java": "public class Solution {\n    public void selectionSort(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] < nums[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            int temp = nums[i];\n            nums[i] = nums[minIndex];\n            nums[minIndex] = temp;\n        }\n    }\n}",
      "javascript": "function selectionSort(nums) {\n    const n = nums.length;\n    for (let i = 0; i < n - 1; i++) {\n        let minIndex = i;\n        for (let j = i + 1; j < n; j++) {\n            if (nums[j] < nums[minIndex]) {\n                minIndex = j;\n            }\n        }\n        [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];\n    }\n    return nums;\n}",
      "rust": "impl Solution {\n    pub fn selection_sort(nums: &mut Vec<i32>) {\n        let n = nums.len();\n        for i in 0..n.saturating_sub(1) {\n            let mut min_index = i;\n            for j in i + 1..n {\n                if nums[j] < nums[min_index] {\n                    min_index = j;\n                }\n            }\n            nums.swap(i, min_index);\n        }\n    }\n}",
      "kotlin": "class Solution {\n    fun selectionSort(nums: MutableList<Int>) {\n        val n = nums.size\n        for (i in 0 until n - 1) {\n            var minIndex = i\n            for (j in i + 1 until n) {\n                if (nums[j] < nums[minIndex]) {\n                    minIndex = j\n                }\n            }\n            val temp = nums[i]\n            nums[i] = nums[minIndex]\n            nums[minIndex] = temp\n        }\n    }\n}"
    },
    "tags": ["basic","comparison","in-place","unstable"]
  },
  {
    "id": "sort-insertion",
    "topic": "Insertion Sort",
    "category": "Sorting",
    "description": "Inserts each element into its sorted position.",
    "time_complexity": { "best": "O(n)", "average": "O(n²)", "worst": "O(n²)" },
    "space_complexity": "O(1)",
    "stable": true,
    "in_place": true,
    "pseudo_code": "for i = 1..n-1:\n  key = a[i]; j = i-1\n  while j >= 0 and a[j] > key:\n    a[j+1] = a[j]; j -= 1\n  a[j+1] = key",
    "visualization": {
      "type": "step_by_step",
      "description": "Highlights key (purple) and shifting (red).",
      "example_steps": [
        "Initial: [12,11,13,5,6]",
        "Insert 11 → [11,12,13,5,6]",
        "Insert 13 (no change)",
        "Insert 5 → [5,11,12,13,6]",
        "Insert 6 → [5,6,11,12,13]"
      ]
    },
    "code": {
      "python": "def insertionSort(nums):\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] > key:\n            nums[j + 1] = nums[j]\n            j -= 1\n        nums[j + 1] = key\n    return nums",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void insertionSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; i++) {\n            int key = nums[i];\n            int j = i - 1;\n            while (j >= 0 && nums[j] > key) {\n                nums[j + 1] = nums[j];\n                j--;\n            }\n            nums[j + 1] = key;\n        }\n    }\n};",
      "java": "public class Solution {\n    public void insertionSort(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            int key = nums[i];\n            int j = i - 1;\n            while (j >= 0 && nums[j] > key) {\n                nums[j + 1] = nums[j];\n                j--;\n            }\n            nums[j + 1] = key;\n        }\n    }\n}",
      "javascript": "function insertionSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        let key = nums[i];\n        let j = i - 1;\n        while (j >= 0 && nums[j] > key) {\n            nums[j + 1] = nums[j];\n            j--;\n        }\n        nums[j + 1] = key;\n    }\n    return nums;\n}",
      "rust": "impl Solution {\n    pub fn insertion_sort(nums: &mut Vec<i32>) {\n        for i in 1..nums.len() {\n            let key = nums[i];\n            let mut j = i as i32 - 1;\n            while j >= 0 && nums[j as usize] > key {\n                nums[(j + 1) as usize] = nums[j as usize];\n                j -= 1;\n            }\n            nums[(j + 1) as usize] = key;\n        }\n    }\n}",
      "kotlin": "class Solution {\n    fun insertionSort(nums: MutableList<Int>) {\n        for (i in 1 until nums.size) {\n            val key = nums[i]\n            var j = i - 1\n            while (j >= 0 && nums[j] > key) {\n                nums[j + 1] = nums[j]\n                j--\n            }\n            nums[j + 1] = key\n        }\n    }\n}"
    },
    "tags": ["basic","comparison","stable","in-place"]
  },
  {
    "id": "sort-merge",
    "topic": "Merge Sort",
    "category": "Sorting",
    "description": "Divide-and-conquer: split, sort, merge.",
    "time_complexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
    "space_complexity": "O(n)",
    "stable": true,
    "in_place": false,
    "pseudo_code": "mergeSort(a):\n  if size <= 1: return a\n  mid = size / 2\n  return merge(mergeSort(left), mergeSort(right))",
    "visualization": {
      "type": "recursive",
      "description": "Shows splitting tree and merging steps.",
      "example_steps": [
        "Split: [38,27,43,3,9,82,10]",
        "…→ single elements",
        "Merge pairs → sorted halves",
        "Final merge → sorted array"
      ]
    },
    "code": {
      "python": "def mergeSort(nums):\n    if len(nums) <= 1:\n        return nums\n    \n    mid = len(nums) // 2\n    left = mergeSort(nums[:mid])\n    right = mergeSort(nums[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> mergeSort(vector<int> nums) {\n        if (nums.size() <= 1) {\n            return nums;\n        }\n        \n        int mid = nums.size() / 2;\n        vector<int> left(nums.begin(), nums.begin() + mid);\n        vector<int> right(nums.begin() + mid, nums.end());\n        \n        left = mergeSort(left);\n        right = mergeSort(right);\n        \n        return merge(left, right);\n    }\n    \nprivate:\n    vector<int> merge(const vector<int>& left, const vector<int>& right) {\n        vector<int> result;\n        int i = 0, j = 0;\n        \n        while (i < left.size() && j < right.size()) {\n            if (left[i] <= right[j]) {\n                result.push_back(left[i++]);\n            } else {\n                result.push_back(right[j++]);\n            }\n        }\n        \n        while (i < left.size()) {\n            result.push_back(left[i++]);\n        }\n        while (j < right.size()) {\n            result.push_back(right[j++]);\n        }\n        \n        return result;\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    public List<Integer> mergeSort(List<Integer> nums) {\n        if (nums.size() <= 1) {\n            return nums;\n        }\n        \n        int mid = nums.size() / 2;\n        List<Integer> left = mergeSort(nums.subList(0, mid));\n        List<Integer> right = mergeSort(nums.subList(mid, nums.size()));\n        \n        return merge(left, right);\n    }\n    \n    private List<Integer> merge(List<Integer> left, List<Integer> right) {\n        List<Integer> result = new ArrayList<>();\n        int i = 0, j = 0;\n        \n        while (i < left.size() && j < right.size()) {\n            if (left.get(i) <= right.get(j)) {\n                result.add(left.get(i++));\n            } else {\n                result.add(right.get(j++));\n            }\n        }\n        \n        while (i < left.size()) {\n            result.add(left.get(i++));\n        }\n        while (j < right.size()) {\n            result.add(right.get(j++));\n        }\n        \n        return result;\n    }\n}",
      "javascript": "function mergeSort(nums) {\n    if (nums.length <= 1) {\n        return nums;\n    }\n    \n    const mid = Math.floor(nums.length / 2);\n    const left = mergeSort(nums.slice(0, mid));\n    const right = mergeSort(nums.slice(mid));\n    \n    return merge(left, right);\n}\n\nfunction merge(left, right) {\n    const result = [];\n    let i = 0, j = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result.push(left[i++]);\n        } else {\n            result.push(right[j++]);\n        }\n    }\n    \n    return result.concat(left.slice(i)).concat(right.slice(j));\n}",
      "rust": "impl Solution {\n    pub fn merge_sort(nums: Vec<i32>) -> Vec<i32> {\n        if nums.len() <= 1 {\n            return nums;\n        }\n        \n        let mid = nums.len() / 2;\n        let left = Self::merge_sort(nums[..mid].to_vec());\n        let right = Self::merge_sort(nums[mid..].to_vec());\n        \n        Self::merge(left, right)\n    }\n    \n    fn merge(left: Vec<i32>, right: Vec<i32>) -> Vec<i32> {\n        let mut result = Vec::with_capacity(left.len() + right.len());\n        let (mut i, mut j) = (0, 0);\n        \n        while i < left.len() && j < right.len() {\n            if left[i] <= right[j] {\n                result.push(left[i]);\n                i += 1;\n            } else {\n                result.push(right[j]);\n                j += 1;\n            }\n        }\n        \n        result.extend(left.into_iter().skip(i));\n        result.extend(right.into_iter().skip(j));\n        result\n    }\n}",
      "kotlin": "class Solution {\n    fun mergeSort(nums: List<Int>): List<Int> {\n        if (nums.size <= 1) {\n            return nums\n        }\n        \n        val mid = nums.size / 2\n        val left = mergeSort(nums.subList(0, mid))\n        val right = mergeSort(nums.subList(mid, nums.size))\n        \n        return merge(left, right)\n    }\n    \n    private fun merge(left: List<Int>, right: List<Int>): List<Int> {\n        val result = ArrayList<Int>()\n        var i = 0\n        var j = 0\n        \n        while (i < left.size && j < right.size) {\n            if (left[i] <= right[j]) {\n                result.add(left[i++])\n            } else {\n                result.add(right[j++])\n            }\n        }\n        \n        while (i < left.size) {\n            result.add(left[i++])\n        }\n        while (j < right.size) {\n            result.add(right[j++])\n        }\n        \n        return result\n    }\n}"
    },
    "tags": ["divide-and-conquer","stable"]
  },
  {
    "id": "sort-quick",
    "topic": "Quick Sort",
    "category": "Sorting",
    "description": "Picks pivot, partitions, recursively sorts.",
    "time_complexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n²)" },
    "space_complexity": "O(log n)",
    "stable": false,
    "in_place": true,
    "pseudo_code": "quickSort(a, l, h):\n  if l < h: p = partition(a, l, h)\n    quickSort(a, l, p-1)\n    quickSort(a, p+1, h)",
    "visualization": {
      "type": "recursive",
      "description": "Highlights pivot (red), partitions, and recursive calls.",
      "example_steps": [
        "Pivot=8 → partition → [5,1,4|8|9,2,7,6]",
        "Recurse left/right",
        "Combine sorted subarrays"
      ]
    },
    "code": {
      "python": "def quickSort(nums):\n    def quickSortHelper(left, right):\n        if left < right:\n            pivotIndex = partition(left, right)\n            quickSortHelper(left, pivotIndex - 1)\n            quickSortHelper(pivotIndex + 1, right)\n    \n    def partition(left, right):\n        pivot = nums[right]\n        i = left - 1\n        \n        for j in range(left, right):\n            if nums[j] <= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[i + 1], nums[right] = nums[right], nums[i + 1]\n        return i + 1\n    \n    quickSortHelper(0, len(nums) - 1)\n    return nums",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void quickSort(vector<int>& nums) {\n        quickSortHelper(nums, 0, nums.size() - 1);\n    }\n    \nprivate:\n    void quickSortHelper(vector<int>& nums, int left, int right) {\n        if (left < right) {\n            int pivotIndex = partition(nums, left, right);\n            quickSortHelper(nums, left, pivotIndex - 1);\n            quickSortHelper(nums, pivotIndex + 1, right);\n        }\n    }\n    \n    int partition(vector<int>& nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left - 1;\n        \n        for (int j = left; j < right; j++) {\n            if (nums[j] <= pivot) {\n                i++;\n                swap(nums[i], nums[j]);\n            }\n        }\n        \n        swap(nums[i + 1], nums[right]);\n        return i + 1;\n    }\n};",
      "java": "public class Solution {\n    public void quickSort(int[] nums) {\n        quickSortHelper(nums, 0, nums.length - 1);\n    }\n    \n    private void quickSortHelper(int[] nums, int left, int right) {\n        if (left < right) {\n            int pivotIndex = partition(nums, left, right);\n            quickSortHelper(nums, left, pivotIndex - 1);\n            quickSortHelper(nums, pivotIndex + 1, right);\n        }\n    }\n    \n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left - 1;\n        \n        for (int j = left; j < right; j++) {\n            if (nums[j] <= pivot) {\n                i++;\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n        \n        int temp = nums[i + 1];\n        nums[i + 1] = nums[right];\n        nums[right] = temp;\n        return i + 1;\n    }\n}",
      "javascript": "function quickSort(nums) {\n    function quickSortHelper(left, right) {\n        if (left < right) {\n            const pivotIndex = partition(left, right);\n            quickSortHelper(left, pivotIndex - 1);\n            quickSortHelper(pivotIndex + 1, right);\n        }\n    }\n    \n    function partition(left, right) {\n        const pivot = nums[right];\n        let i = left - 1;\n        \n        for (let j = left; j < right; j++) {\n            if (nums[j] <= pivot) {\n                i++;\n                [nums[i], nums[j]] = [nums[j], nums[i]];\n            }\n        }\n        \n        [nums[i + 1], nums[right]] = [nums[right], nums[i + 1]];\n        return i + 1;\n    }\n    \n    quickSortHelper(0, nums.length - 1);\n    return nums;\n}",
      "rust": "impl Solution {\n    pub fn quick_sort(nums: &mut Vec<i32>) {\n        let len = nums.len();\n        if len > 1 {\n            Self::quick_sort_helper(nums, 0, len - 1);\n        }\n    }\n    \n    fn quick_sort_helper(nums: &mut Vec<i32>, left: usize, right: usize) {\n        if left < right {\n            let pivot_index = Self::partition(nums, left, right);\n            if pivot_index > 0 {\n                Self::quick_sort_helper(nums, left, pivot_index - 1);\n            }\n            Self::quick_sort_helper(nums, pivot_index + 1, right);\n        }\n    }\n    \n    fn partition(nums: &mut Vec<i32>, left: usize, right: usize) -> usize {\n        let pivot = nums[right];\n        let mut i = left as i32 - 1;\n        \n        for j in left..right {\n            if nums[j] <= pivot {\n                i += 1;\n                nums.swap(i as usize, j);\n            }\n        }\n        \n        nums.swap((i + 1) as usize, right);\n        (i + 1) as usize\n    }\n}",
      "kotlin": "class Solution {\n    fun quickSort(nums: MutableList<Int>) {\n        quickSortHelper(nums, 0, nums.size - 1)\n    }\n    \n    private fun quickSortHelper(nums: MutableList<Int>, left: Int, right: Int) {\n        if (left < right) {\n            val pivotIndex = partition(nums, left, right)\n            if (pivotIndex > 0) {\n                quickSortHelper(nums, left, pivotIndex - 1)\n            }\n            quickSortHelper(nums, pivotIndex + 1, right)\n        }\n    }\n    \n    private fun partition(nums: MutableList<Int>, left: Int, right: Int): Int {\n        val pivot = nums[right]\n        var i = left - 1\n        \n        for (j in left until right) {\n            if (nums[j] <= pivot) {\n                i++\n                val temp = nums[i]\n                nums[i] = nums[j]\n                nums[j] = temp\n            }\n        }\n        \n        val temp = nums[i + 1]\n        nums[i + 1] = nums[right]\n        nums[right] = temp\n        return i + 1\n    }\n}"
    },
    "tags": ["divide-and-conquer","unstable","in-place"]
  },
  {
    "id": "search-linear",
    "topic": "Linear Search",
    "category": "Searching",
    "description": "Sequentially scans for target in unsorted data.",
    "time_complexity": { "best": "O(1)", "average": "O(n)", "worst": "O(n)" },
    "space_complexity": "O(1)",
    "pseudo_code": "for i in 0..n-1: if a[i]==t: return i\nreturn -1",
    "visualization": {
      "type": "step_by_step",
      "description": "Highlights current element being checked (yellow).",
      "example_steps": [
        "Check a[0]=7",
        "Check a[1]=3",
        "… until target found"
      ]
    },
    "code": {
      "python": "def linearSearch(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int linearSearch(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};",
      "java": "public class Solution {\n    public int linearSearch(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
      "javascript": "function linearSearch(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "rust": "impl Solution {\n    pub fn linear_search(nums: &Vec<i32>, target: i32) -> i32 {\n        for (i, &num) in nums.iter().enumerate() {\n            if num == target {\n                return i as i32;\n            }\n        }\n        -1\n    }\n}",
      "kotlin": "class Solution {\n    fun linearSearch(nums: IntArray, target: Int): Int {\n        for (i in nums.indices) {\n            if (nums[i] == target) {\n                return i\n            }\n        }\n        return -1\n    }\n}"
    },
    "tags": ["basic","unsorted","O(n)"]
  },
  {
    "id": "search-binary",
    "topic": "Binary Search",
    "category": "Searching",
    "description": "Halves search range on sorted data.",
    "time_complexity": { "best": "O(1)", "average": "O(log n)", "worst": "O(log n)" },
    "space_complexity": "O(1)",
    "pseudo_code": "l = 0; r = n-1\nwhile l <= r:\n  m = (l + r) // 2\n  if a[m] == t: return m\n  if a[m] < t: l = m + 1 else: r = m - 1\nreturn -1",
    "visualization": {
      "type": "step_by_step",
      "description": "Highlights mid element (red) and updates bounds.",
      "example_steps": [
        "l=0,r=6,m=3",
        "Compare a[3]",
        "Update l or r",
        "Repeat until found"
      ]
    },
    "code": {
      "python": "def binarySearch(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int binarySearch(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n};",
      "java": "public class Solution {\n    public int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
      "javascript": "function binarySearch(nums, target) {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}",
      "rust": "impl Solution {\n    pub fn binary_search(nums: &Vec<i32>, target: i32) -> i32 {\n        let mut left = 0i32;\n        let mut right = nums.len() as i32 - 1;\n        \n        while left <= right {\n            let mid = left + (right - left) / 2;\n            \n            if nums[mid as usize] == target {\n                return mid;\n            } else if nums[mid as usize] < target {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        -1\n    }\n}",
      "kotlin": "class Solution {\n    fun binarySearch(nums: IntArray, target: Int): Int {\n        var left = 0\n        var right = nums.size - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            when {\n                nums[mid] == target -> return mid\n                nums[mid] < target -> left = mid + 1\n                else -> right = mid - 1\n            }\n        }\n        \n        return -1\n    }\n}"
    },
    "tags": ["sorted","logn"]
  },
  {
    "id": "graph-bfs",
    "topic": "Breadth-First Search (BFS)",
    "category": "Graph",
    "description": "Level-order traversal via queue; finds shortest path in unweighted graph.",
    "time_complexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
    "space_complexity": "O(V)",
    "pseudo_code": "enqueue(s); visited[s]=true\nwhile q:\n  u=q.dequeue()\n  for v in adj[u]:\n    if not visited[v]: visited[v]=true; enqueue(v)",
    "visualization": {
      "type": "layered",
      "description": "Highlights each level of graph in waves.",
      "example_steps": [
        "Start at node A",
        "Visit neighbors B, C",
        "Then D, E…"
      ]
    },
    "code": {
      "python": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result",
      "cpp": "#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> bfs(vector<vector<int>>& graph, int start) {\n        unordered_set<int> visited;\n        queue<int> q;\n        vector<int> result;\n        \n        visited.insert(start);\n        q.push(start);\n        \n        while (!q.empty()) {\n            int vertex = q.front();\n            q.pop();\n            result.push_back(vertex);\n            \n            for (int neighbor : graph[vertex]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    visited.insert(neighbor);\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    public List<Integer> bfs(List<List<Integer>> graph, int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> result = new ArrayList<>();\n        \n        visited.add(start);\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int vertex = queue.poll();\n            result.add(vertex);\n            \n            for (int neighbor : graph.get(vertex)) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
      "javascript": "function bfs(graph, start) {\n    const visited = new Set();\n    const queue = [start];\n    const result = [];\n    \n    visited.add(start);\n    \n    while (queue.length > 0) {\n        const vertex = queue.shift();\n        result.push(vertex);\n        \n        for (const neighbor of graph[vertex]) {\n            if (!visited.has(neighbor)) {\n                visited.add(neighbor);\n                queue.push(neighbor);\n            }\n        }\n    }\n    \n    return result;\n}",
      "rust": "use std::collections::{VecDeque, HashSet};\n\nimpl Solution {\n    pub fn bfs(graph: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        let mut result = Vec::new();\n        \n        visited.insert(start);\n        queue.push_back(start);\n        \n        while let Some(vertex) = queue.pop_front() {\n            result.push(vertex);\n            \n            for &neighbor in &graph[vertex] {\n                if !visited.contains(&neighbor) {\n                    visited.insert(neighbor);\n                    queue.push_back(neighbor);\n                }\n            }\n        }\n        \n        result\n    }\n}",
      "kotlin": "import java.util.*\n\nclass Solution {\n    fun bfs(graph: List<List<Int>>, start: Int): List<Int> {\n        val visited = HashSet<Int>()\n        val queue: Queue<Int> = LinkedList()\n        val result = ArrayList<Int>()\n        \n        visited.add(start)\n        queue.offer(start)\n        \n        while (queue.isNotEmpty()) {\n            val vertex = queue.poll()\n            result.add(vertex)\n            \n            for (neighbor in graph[vertex]) {\n                if (neighbor !in visited) {\n                    visited.add(neighbor)\n                    queue.offer(neighbor)\n                }\n            }\n        }\n        \n        return result\n    }\n}"
    },
    "tags": ["graph","traversal","shortest-unweighted"]
  },
  {
    "id": "graph-dfs",
    "topic": "Depth-First Search (DFS)",
    "category": "Graph",
    "description": "Explores as far as possible along each branch before backtracking.",
    "time_complexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
    "space_complexity": "O(V)",
    "pseudo_code": "dfs(u):\n  visited[u] = true\n  for v in adj[u]: if not visited[v]: dfs(v)",
    "visualization": {
      "type": "stack_recursion",
      "description": "Shows recursion stack growth and backtracking.",
      "example_steps": [
        "Visit A → B → C",
        "Backtrack to B → D",
        "…"
      ]
    },
    "code": {
      "python": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    result = [start]\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            result.extend(dfs(graph, neighbor, visited))\n    \n    return result",
      "cpp": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> dfs(vector<vector<int>>& graph, int start) {\n        unordered_set<int> visited;\n        vector<int> result;\n        dfsHelper(graph, start, visited, result);\n        return result;\n    }\n    \nprivate:\n    void dfsHelper(vector<vector<int>>& graph, int vertex, \n                   unordered_set<int>& visited, vector<int>& result) {\n        visited.insert(vertex);\n        result.push_back(vertex);\n        \n        for (int neighbor : graph[vertex]) {\n            if (visited.find(neighbor) == visited.end()) {\n                dfsHelper(graph, neighbor, visited, result);\n            }\n        }\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    public List<Integer> dfs(List<List<Integer>> graph, int start) {\n        Set<Integer> visited = new HashSet<>();\n        List<Integer> result = new ArrayList<>();\n        dfsHelper(graph, start, visited, result);\n        return result;\n    }\n    \n    private void dfsHelper(List<List<Integer>> graph, int vertex,\n                          Set<Integer> visited, List<Integer> result) {\n        visited.add(vertex);\n        result.add(vertex);\n        \n        for (int neighbor : graph.get(vertex)) {\n            if (!visited.contains(neighbor)) {\n                dfsHelper(graph, neighbor, visited, result);\n            }\n        }\n    }\n}",
      "javascript": "function dfs(graph, start, visited = new Set()) {\n    visited.add(start);\n    const result = [start];\n    \n    for (const neighbor of graph[start]) {\n        if (!visited.has(neighbor)) {\n            result.push(...dfs(graph, neighbor, visited));\n        }\n    }\n    \n    return result;\n}",
      "rust": "use std::collections::HashSet;\n\nimpl Solution {\n    pub fn dfs(graph: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {\n        let mut visited = HashSet::new();\n        let mut result = Vec::new();\n        Self::dfs_helper(graph, start, &mut visited, &mut result);\n        result\n    }\n    \n    fn dfs_helper(graph: &Vec<Vec<usize>>, vertex: usize,\n                  visited: &mut HashSet<usize>, result: &mut Vec<usize>) {\n        visited.insert(vertex);\n        result.push(vertex);\n        \n        for &neighbor in &graph[vertex] {\n            if !visited.contains(&neighbor) {\n                Self::dfs_helper(graph, neighbor, visited, result);\n            }\n        }\n    }\n}",
      "kotlin": "class Solution {\n    fun dfs(graph: List<List<Int>>, start: Int): List<Int> {\n        val visited = HashSet<Int>()\n        val result = ArrayList<Int>()\n        dfsHelper(graph, start, visited, result)\n        return result\n    }\n    \n    private fun dfsHelper(graph: List<List<Int>>, vertex: Int,\n                         visited: HashSet<Int>, result: ArrayList<Int>) {\n        visited.add(vertex)\n        result.add(vertex)\n        \n        for (neighbor in graph[vertex]) {\n            if (neighbor !in visited) {\n                dfsHelper(graph, neighbor, visited, result)\n            }\n        }\n    }\n}"
    },
    "tags": ["graph","traversal","recursion"]
  },
  {
    "id": "graph-dijkstra",
    "topic": "Dijkstra's Algorithm",
    "category": "Graph",
    "description": "Finds shortest paths from source in weighted graph (non-negative).",
    "time_complexity": { "best": "O((V+E) log V)", "average": "O((V+E) log V)", "worst": "O((V+E) log V)" },
    "space_complexity": "O(V)",
    "pseudo_code": "dist[src] = 0; push(src)\nwhile pq:\n  u = pop_min()\n  for (v, w) in adj[u]:\n    if dist[v] > dist[u] + w: dist[v] = dist[u] + w; push(v)",
    "visualization": {
      "type": "priority_queue",
      "description": "Shows distance updates on nodes, priority queue state.",
      "example_steps": [
        "Init dist[A]=0, others=∞",
        "Relax neighbors",
        "Pop next-min node",
        "… until all nodes processed"
      ]
    },
    "code": {
      "python": "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    distances = defaultdict(lambda: float('inf'))\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        currentDist, currentVertex = heapq.heappop(pq)\n        \n        if currentDist > distances[currentVertex]:\n            continue\n        \n        for neighbor, weight in graph[currentVertex]:\n            distance = currentDist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return dict(distances)",
      "cpp": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <limits>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, long long> dijkstra(unordered_map<int, vector<pair<int, int>>>& graph, int start) {\n        unordered_map<int, long long> distances;\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n        \n        distances[start] = 0;\n        pq.push({0, start});\n        \n        while (!pq.empty()) {\n            auto [currentDist, currentVertex] = pq.top();\n            pq.pop();\n            \n            if (distances.count(currentVertex) && currentDist > distances[currentVertex]) {\n                continue;\n            }\n            \n            for (auto [neighbor, weight] : graph[currentVertex]) {\n                long long distance = currentDist + weight;\n                \n                if (!distances.count(neighbor) || distance < distances[neighbor]) {\n                    distances[neighbor] = distance;\n                    pq.push({distance, neighbor});\n                }\n            }\n        }\n        \n        return distances;\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    public Map<Integer, Long> dijkstra(Map<Integer, List<int[]>> graph, int start) {\n        Map<Integer, Long> distances = new HashMap<>();\n        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\n        \n        distances.put(start, 0L);\n        pq.offer(new long[]{0, start});\n        \n        while (!pq.isEmpty()) {\n            long[] current = pq.poll();\n            long currentDist = current[0];\n            int currentVertex = (int) current[1];\n            \n            if (distances.containsKey(currentVertex) && currentDist > distances.get(currentVertex)) {\n                continue;\n            }\n            \n            if (graph.containsKey(currentVertex)) {\n                for (int[] edge : graph.get(currentVertex)) {\n                    int neighbor = edge[0];\n                    int weight = edge[1];\n                    long distance = currentDist + weight;\n                    \n                    if (!distances.containsKey(neighbor) || distance < distances.get(neighbor)) {\n                        distances.put(neighbor, distance);\n                        pq.offer(new long[]{distance, neighbor});\n                    }\n                }\n            }\n        }\n        \n        return distances;\n    }\n}",
      "javascript": "function dijkstra(graph, start) {\n    const distances = new Map();\n    const pq = new PriorityQueue((a, b) => a[0] - b[0]);\n    \n    distances.set(start, 0);\n    pq.enqueue([0, start]);\n    \n    while (!pq.isEmpty()) {\n        const [currentDist, currentVertex] = pq.dequeue();\n        \n        if (distances.has(currentVertex) && currentDist > distances.get(currentVertex)) {\n            continue;\n        }\n        \n        if (graph.has(currentVertex)) {\n            for (const [neighbor, weight] of graph.get(currentVertex)) {\n                const distance = currentDist + weight;\n                \n                if (!distances.has(neighbor) || distance < distances.get(neighbor)) {\n                    distances.set(neighbor, distance);\n                    pq.enqueue([distance, neighbor]);\n                }\n            }\n        }\n    }\n    \n    return distances;\n}",
      "rust": "use std::collections::{HashMap, BinaryHeap};\nuse std::cmp::Reverse;\n\nimpl Solution {\n    pub fn dijkstra(graph: &HashMap<i32, Vec<(i32, i32)>>, start: i32) -> HashMap<i32, i64> {\n        let mut distances = HashMap::new();\n        let mut pq = BinaryHeap::new();\n        \n        distances.insert(start, 0i64);\n        pq.push(Reverse((0i64, start)));\n        \n        while let Some(Reverse((current_dist, current_vertex))) = pq.pop() {\n            if let Some(&dist) = distances.get(&current_vertex) {\n                if current_dist > dist {\n                    continue;\n                }\n            }\n            \n            if let Some(neighbors) = graph.get(&current_vertex) {\n                for &(neighbor, weight) in neighbors {\n                    let distance = current_dist + weight as i64;\n                    \n                    let should_update = distances.get(&neighbor)\n                        .map_or(true, |&d| distance < d);\n                    \n                    if should_update {\n                        distances.insert(neighbor, distance);\n                        pq.push(Reverse((distance, neighbor)));\n                    }\n                }\n            }\n        }\n        \n        distances\n    }\n}",
      "kotlin": "import java.util.*\n\nclass Solution {\n    fun dijkstra(graph: Map<Int, List<Pair<Int, Int>>>, start: Int): Map<Int, Long> {\n        val distances = mutableMapOf<Int, Long>()\n        val pq = PriorityQueue<Pair<Long, Int>>(compareBy { it.first })\n        \n        distances[start] = 0L\n        pq.offer(Pair(0L, start))\n        \n        while (pq.isNotEmpty()) {\n            val (currentDist, currentVertex) = pq.poll()\n            \n            if (distances.containsKey(currentVertex) && currentDist > distances[currentVertex]!!) {\n                continue\n            }\n            \n            graph[currentVertex]?.forEach { (neighbor, weight) ->\n                val distance = currentDist + weight\n                \n                if (!distances.containsKey(neighbor) || distance < distances[neighbor]!!) {\n                    distances[neighbor] = distance\n                    pq.offer(Pair(distance, neighbor))\n                }\n            }\n        }\n        \n        return distances\n    }\n}"
    },
    "tags": ["weighted","shortest-path","priority-queue"]
  },
  {
    "id": "graph-toposort",
    "topic": "Topological Sort",
    "category": "Graph",
    "description": "Linear ordering of DAG vertices so that edges go from earlier to later.",
    "time_complexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
    "space_complexity": "O(V)",
    "pseudo_code": "compute indegree[]\nenqueue vertices with indegree = 0\nwhile q:\n  u = q.dequeue(); output u\n  for v in adj[u]: indegree[v]--; if indegree[v]==0: enqueue(v)",
    "visualization": {
      "type": "hierarchy",
      "description": "Shows layers of DAG being removed in order.",
      "example_steps": [
        "Enqueue zeros",
        "Remove and update neighbors",
        "…"
      ]
    },
    "code": {
      "python": "from collections import deque\n\ndef topo_sort(adj):\n    n = len(adj)\n    indeg =  * n\n    \n    # Calculate indegrees\n    for u in range(n):\n        for v in adj[u]:\n            indeg[v] += 1\n    \n    # Enqueue all vertices with indegree 0\n    q = deque([i for i in range(n) if indeg[i] == 0])\n    order = []\n    \n    while q:\n        u = q.popleft()\n        order.append(u)\n        \n        # Reduce indegree for all neighbors\n        for v in adj[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                q.append(v)\n    \n    return order if len(order) == n else None",
      "cpp": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> topo_sort(const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> indeg(n, 0);\n    \n    // Calculate indegrees\n    for (int u = 0; u < n; ++u) {\n        for (int v : adj[u]) {\n            indeg[v]++;\n        }\n    }\n    \n    // Enqueue vertices with indegree 0\n    queue<int> q;\n    for (int i = 0; i < n; i++) {\n        if (indeg[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<int> order;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        order.push_back(u);\n        \n        for (int v : adj[u]) {\n            if (--indeg[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n    \n    return order.size() == n ? order : vector<int>();\n}",
      "java": "import java.util.*;\n\npublic static List<Integer> topoSort(List<List<Integer>> adj) {\n    int n = adj.size();\n    int[] indeg = new int[n];\n    \n    // Calculate indegrees\n    for (int u = 0; u < n; u++) {\n        for (int v : adj.get(u)) {\n            indeg[v]++;\n        }\n    }\n    \n    // Enqueue vertices with indegree 0\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (indeg[i] == 0) {\n            q.add(i);\n        }\n    }\n    \n    List<Integer> order = new ArrayList<>();\n    while (!q.isEmpty()) {\n        int u = q.poll();\n        order.add(u);\n        \n        for (int v : adj.get(u)) {\n            if (--indeg[v] == 0) {\n                q.add(v);\n            }\n        }\n    }\n    \n    return order.size() == n ? order : null;\n}",
      "javascript": "function topoSort(adj) {\n    const n = adj.length;\n    const indeg = Array(n).fill(0);\n    \n    // Calculate indegrees\n    for (let u = 0; u < n; u++) {\n        for (const v of adj[u]) {\n            indeg[v]++;\n        }\n    }\n    \n    // Enqueue vertices with indegree 0\n    const q = [];\n    const order = [];\n    for (let i = 0; i < n; i++) {\n        if (indeg[i] === 0) {\n            q.push(i);\n        }\n    }\n    \n    while (q.length) {\n        const u = q.shift();\n        order.push(u);\n        \n        for (const v of adj[u]) {\n            indeg[v]--;\n            if (indeg[v] === 0) {\n                q.push(v);\n            }\n        }\n    }\n    \n    return order.length === n ? order : null;\n}",
      "rust": "use std::collections::VecDeque;\n\npub fn topo_sort(adj: &Vec<Vec<usize>>) -> Option<Vec<usize>> {\n    let n = adj.len();\n    let mut indeg = vec![0usize; n];\n    \n    // Calculate indegrees\n    for u in 0..n {\n        for &v in &adj[u] {\n            indeg[v] += 1;\n        }\n    }\n    \n    // Enqueue vertices with indegree 0\n    let mut q = VecDeque::new();\n    for i in 0..n {\n        if indeg[i] == 0 {\n            q.push_back(i);\n        }\n    }\n    \n    let mut order = Vec::new();\n    while let Some(u) = q.pop_front() {\n        order.push(u);\n        \n        for &v in &adj[u] {\n            indeg[v] -= 1;\n            if indeg[v] == 0 {\n                q.push_back(v);\n            }\n        }\n    }\n    \n    if order.len() == n { Some(order) } else { None }\n}",
      "kotlin": "fun topoSort(adj: List<List<Int>>): List<Int>? {\n    val n = adj.size\n    val indeg = IntArray(n)\n    \n    // Calculate indegrees\n    for (u in 0 until n) {\n        for (v in adj[u]) {\n            indeg[v]++\n        }\n    }\n    \n    // Enqueue vertices with indegree 0\n    val q = ArrayDeque<Int>()\n    for (i in 0 until n) {\n        if (indeg[i] == 0) {\n            q.add(i)\n        }\n    }\n    \n    val order = mutableListOf<Int>()\n    while (q.isNotEmpty()) {\n        val u = q.removeFirst()\n        order.add(u)\n        \n        for (v in adj[u]) {\n            indeg[v]--\n            if (indeg[v] == 0) {\n                q.add(v)\n            }\n        }\n    }\n    \n    return if (order.size == n) order else null\n}"
    },
    "tags": ["DAG","ordering"]
  },
  {
    "id": "ds-stack",
    "topic": "Stack",
    "category": "Data Structure",
    "description": "LIFO structure supporting push/pop/peek.",
    "time_complexity": { "push": "O(1)", "pop": "O(1)", "peek": "O(1)" },
    "space_complexity": "O(n)",
    "pseudo_code": "push(x): add to top\npop(): remove from top\npeek(): top element",
    "visualization": {
      "type": "vertical",
      "description": "Shows stack growth/shrink on push/pop.",
      "example_steps": [
        "Push 1,2,3",
        "Pop → remove 3"
      ]
    },
    "code": {
      "python": "# Stack implementation using list\nstack = []\n\n# Push operation\nstack.append(x)\n\n# Pop operation\nif stack:\n    x = stack.pop()\n\n# Peek operation\nif stack:\n    top = stack[-1]",
      "cpp": "#include <vector>\nusing namespace std;\n\nstruct Stack {\n    vector<int> s;\n    \n    void push(int x) {\n        s.push_back(x);\n    }\n    \n    int pop() {\n        int v = s.back();\n        s.pop_back();\n        return v;\n    }\n    \n    int top() {\n        return s.back();\n    }\n    \n    bool empty() {\n        return s.empty();\n    }\n};",
      "java": "import java.util.*;\n\n// Stack implementation\nStack<Integer> stack = new Stack<>();\n\n// Push operation\nstack.push(x);\n\n// Pop operation\nif (!stack.isEmpty()) {\n    int v = stack.pop();\n}\n\n// Peek operation\nif (!stack.isEmpty()) {\n    int top = stack.peek();\n}",
      "javascript": "// Stack implementation using array\nconst stack = [];\n\n// Push operation\nstack.push(x);\n\n// Pop operation\nif (stack.length > 0) {\n    const v = stack.pop();\n}\n\n// Peek operation\nif (stack.length > 0) {\n    const top = stack[stack.length - 1];\n}",
      "rust": "// Stack implementation using Vec\nlet mut stack: Vec<i32> = Vec::new();\n\n// Push operation\nstack.push(x);\n\n// Pop operation\nif let Some(v) = stack.pop() {\n    // Use v\n}\n\n// Peek operation\nif let Some(&top) = stack.last() {\n    // Use top\n}",
      "kotlin": "// Stack implementation using ArrayDeque\nval stack = ArrayDeque<Int>()\n\n// Push operation\nstack.addLast(x)\n\n// Pop operation\nif (stack.isNotEmpty()) {\n    val v = stack.removeLast()\n}\n\n// Peek operation\nif (stack.isNotEmpty()) {\n    val top = stack.last()\n}"
    },
    "tags": ["LIFO","basic"]
  },
  {
    "id": "ds-queue",
    "topic": "Queue",
    "category": "Data Structure",
    "description": "FIFO structure with enqueue/dequeue.",
    "time_complexity": { "enqueue": "O(1)", "dequeue": "O(1)" },
    "space_complexity": "O(n)",
    "pseudo_code": "enqueue(x): add rear\ndequeue(): remove front",
    "visualization": {
      "type": "horizontal",
      "description": "Shows queue advancing on enqueue/dequeue.",
      "example_steps": [
        "Enqueue 1,2,3",
        "Dequeue → remove 1"
      ]
    },
    "code": {
      "python": "from collections import deque\n\n# Queue implementation\nq = deque()\n\n# Enqueue operation\nq.append(x)\n\n# Dequeue operation\nif q:\n    x = q.popleft()\n\n# Peek front\nif q:\n    front = q",
      "cpp": "#include <queue>\nusing namespace std;\n\n// Queue implementation\nqueue<int> q;\n\n// Enqueue operation\nq.push(x);\n\n// Dequeue operation\nif (!q.empty()) {\n    int v = q.front();\n    q.pop();\n}\n\n// Peek front\nif (!q.empty()) {\n    int front = q.front();\n}",
      "java": "import java.util.*;\n\n// Queue implementation\nQueue<Integer> q = new LinkedList<>();\n\n// Enqueue operation\nq.add(x);\n\n// Dequeue operation\nif (!q.isEmpty()) {\n    int v = q.remove();\n}\n\n// Peek front\nif (!q.isEmpty()) {\n    int front = q.peek();\n}",
      "javascript": "// Queue implementation using array\nconst q = [];\n\n// Enqueue operation\nq.push(x);\n\n// Dequeue operation\nif (q.length > 0) {\n    const v = q.shift();\n}\n\n// Peek front\nif (q.length > 0) {\n    const front = q;\n}",
      "rust": "use std::collections::VecDeque;\n\n// Queue implementation\nlet mut q: VecDeque<i32> = VecDeque::new();\n\n// Enqueue operation\nq.push_back(x);\n\n// Dequeue operation\nif let Some(v) = q.pop_front() {\n    // Use v\n}\n\n// Peek front\nif let Some(&front) = q.front() {\n    // Use front\n}",
      "kotlin": "// Queue implementation using ArrayDeque\nval q: ArrayDeque<Int> = ArrayDeque()\n\n// Enqueue operation\nq.addLast(x)\n\n// Dequeue operation\nif (q.isNotEmpty()) {\n    val v = q.removeFirst()\n}\n\n// Peek front\nif (q.isNotEmpty()) {\n    val front = q.first()\n}"
    },
    "tags": ["FIFO","basic"]
  },
  {
    "id": "ds-heap",
    "topic": "Heap / Priority Queue",
    "category": "Heap",
    "description": "Binary heap supporting fast min/max extraction.",
    "time_complexity": { "insert": "O(log n)", "extract": "O(log n)", "peek": "O(1)" },
    "space_complexity": "O(n)",
    "pseudo_code": "insert: add, bubble up\nextract: swap root+last, pop, bubble down",
    "visualization": {
      "type": "tree",
      "description": "Shows heap as tree, bubble up/down animations.",
      "example_steps": [
        "Insert elements → heapify up",
        "Extract root → heapify down"
      ]
    },
    "code": {
      "python": "import heapq\n\n# Min heap implementation\npq = []\n\n# Insert operation\nheapq.heappush(pq, x)\n\n# Extract min operation\nif pq:\n    min_val = heapq.heappop(pq)\n\n# Peek min\nif pq:\n    min_val = pq\n\n# For max heap, negate values\nmax_heap = []\nheapq.heappush(max_heap, -x)  # Insert -x\nmax_val = -heapq.heappop(max_heap)  # Extract and negate",
      "cpp": "#include <queue>\n#include <vector>\nusing namespace std;\n\n// Min heap\npriority_queue<int, vector<int>, greater<int>> min_pq;\n\n// Insert operation\nmin_pq.push(x);\n\n// Extract min operation\nif (!min_pq.empty()) {\n    int min_val = min_pq.top();\n    min_pq.pop();\n}\n\n// Max heap (default)\npriority_queue<int> max_pq;\nmax_pq.push(x);\nif (!max_pq.empty()) {\n    int max_val = max_pq.top();\n    max_pq.pop();\n}",
      "java": "import java.util.*;\n\n// Min heap\nPriorityQueue<Integer> minPq = new PriorityQueue<>();\n\n// Insert operation\nminPq.add(x);\n\n// Extract min operation\nif (!minPq.isEmpty()) {\n    int minVal = minPq.poll();\n}\n\n// Peek min\nif (!minPq.isEmpty()) {\n    int minVal = minPq.peek();\n}\n\n// Max heap\nPriorityQueue<Integer> maxPq = new PriorityQueue<>(Collections.reverseOrder());\nmaxPq.add(x);\nif (!maxPq.isEmpty()) {\n    int maxVal = maxPq.poll();\n}",
      "javascript": "// JavaScript doesn't have built-in heap\n// Simple implementation using array + sort (inefficient for demo)\nlet pq = [];\n\n// Insert operation\npq.push(x);\npq.sort((a, b) => a - b);  // Keep sorted for min heap\n\n// Extract min operation\nif (pq.length > 0) {\n    const minVal = pq.shift();\n}\n\n// For production, use a proper heap library\n// or implement binary heap manually",
      "rust": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n// Max heap (default)\nlet mut max_pq = BinaryHeap::new();\nmax_pq.push(x);\nif let Some(max_val) = max_pq.pop() {\n    // Use max_val\n}\n\n// Min heap using Reverse\nlet mut min_pq = BinaryHeap::new();\nmin_pq.push(Reverse(x));\nif let Some(Reverse(min_val)) = min_pq.pop() {\n    // Use min_val\n}",
      "kotlin": "import java.util.*\n\n// Min heap\nval minPq = PriorityQueue<Int>()\n\n// Insert operation\nminPq.add(x)\n\n// Extract min operation\nif (minPq.isNotEmpty()) {\n    val minVal = minPq.poll()\n}\n\n// Peek min\nif (minPq.isNotEmpty()) {\n    val minVal = minPq.peek()\n}\n\n// Max heap\nval maxPq = PriorityQueue<Int>(Collections.reverseOrder())\nmaxPq.add(x)\nif (maxPq.isNotEmpty()) {\n    val maxVal = maxPq.poll()\n}"
    },
    "tags": ["priority-queue","heap"]
  },
  {
    "id": "ds-hashmap",
    "topic": "Hash Map",
    "category": "Data Structure",
    "description": "Key → value mapping via hashing.",
    "time_complexity": { "lookup": "O(1)", "insert": "O(1)", "delete": "O(1)" },
    "space_complexity": "O(n)",
    "pseudo_code": "map[k] = v; v = map[k]",
    "visualization": {
      "type": "buckets",
      "description": "Shows buckets and chaining/open addressing.",
      "example_steps": [
        "Hash key → bucket index",
        "Insert in bucket"
      ]
    },
    "code": {
      "python": "# Dictionary/HashMap implementation\nd = {}\n\n# Insert operation\nd['key'] = value\nd[key] = value\n\n# Lookup operation\nif 'key' in d:\n    value = d['key']\n\n# Delete operation\nif 'key' in d:\n    del d['key']\n\n# Get with default\nvalue = d.get('key', default_value)",
      "cpp": "#include <unordered_map>\nusing namespace std;\n\n// HashMap implementation\nunordered_map<string, int> m;\n\n// Insert operation\nm[\"key\"] = value;\nm.insert({\"key\", value});\n\n// Lookup operation\nif (m.find(\"key\") != m.end()) {\n    int value = m[\"key\"];\n}\n\n// Delete operation\nm.erase(\"key\");\n\n// Check existence\nif (m.count(\"key\")) {\n    // Key exists\n}",
      "java": "import java.util.*;\n\n// HashMap implementation\nMap<String, Integer> m = new HashMap<>();\n\n// Insert operation\nm.put(\"key\", value);\n\n// Lookup operation\nif (m.containsKey(\"key\")) {\n    int value = m.get(\"key\");\n}\n\n// Delete operation\nm.remove(\"key\");\n\n// Get with default\nint value = m.getOrDefault(\"key\", defaultValue);\n\n// Iterate over entries\nfor (Map.Entry<String, Integer> entry : m.entrySet()) {\n    String key = entry.getKey();\n    int value = entry.getValue();\n}",
      "javascript": "// Map implementation\nconst m = new Map();\n\n// Insert operation\nm.set('key', value);\n\n// Lookup operation\nif (m.has('key')) {\n    const value = m.get('key');\n}\n\n// Delete operation\nm.delete('key');\n\n// Object as map (alternative)\nconst obj = {};\nobj['key'] = value;\nif ('key' in obj) {\n    const value = obj['key'];\n}\ndelete obj['key'];",
      "rust": "use std::collections::HashMap;\n\n// HashMap implementation\nlet mut m: HashMap<String, i32> = HashMap::new();\n\n// Insert operation\nm.insert(\"key\".to_string(), value);\n\n// Lookup operation\nif let Some(value) = m.get(\"key\") {\n    // Use value\n}\n\n// Delete operation\nm.remove(\"key\");\n\n// Check existence\nif m.contains_key(\"key\") {\n    // Key exists\n}\n\n// Get with default\nlet value = m.get(\"key\").unwrap_or(&default_value);",
      "kotlin": "// HashMap implementation\nval m = HashMap<String, Int>()\n\n// Insert operation\nm[\"key\"] = value\nm.put(\"key\", value)\n\n// Lookup operation\nif (m.containsKey(\"key\")) {\n    val value = m[\"key\"]\n}\n\n// Delete operation\nm.remove(\"key\")\n\n// Get with default\nval value = m.getOrDefault(\"key\", defaultValue)\n\n// Null-safe access\nval value = m[\"key\"] ?: defaultValue"
    },
    "tags": ["hashing","dict","map"]
  },
  {
    "id": "ds-unionfind",
    "topic": "Disjoint Set Union (Union-Find)",
    "category": "Data Structure",
    "description": "Manages disjoint sets with union and find operations (path compression).",
    "time_complexity": { "union": "O(α(n))", "find": "O(α(n))" },
    "space_complexity": "O(n)",
    "pseudo_code": "makeSet(x): parent[x]=x; rank[x]=0\nfind(x): if parent[x] != x: parent[x] = find(parent[x]); return parent[x]\nunion(x,y): rx = find(x); ry = find(y)\n if rank[rx] < rank[ry]: parent[rx] = ry\n elif rank[rx] > rank[ry]: parent[ry] = rx\n else: parent[ry] = rx; rank[rx] += 1",
    "visualization": {
      "type": "forest",
      "description": "Shows tree roots and path compression steps.",
      "example_steps": [
        "Initial sets",
        "Union operations link roots",
        "Find operations compress paths"
      ]
    },
    "code": {
      "python": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank =  * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False  # Already in same set\n        \n        # Union by rank\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True  # Union successful\n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)",
      "cpp": "#include <vector>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent, rank;\n    \n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);  // Path compression\n        }\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) {\n            return false;  // Already in same set\n        }\n        \n        // Union by rank\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        return true;  // Union successful\n    }\n    \n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};",
      "java": "public class DSU {\n    private int[] parent;\n    private int[] rank;\n    \n    public DSU(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);  // Path compression\n        }\n        return parent[x];\n    }\n    \n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) {\n            return false;  // Already in same set\n        }\n        \n        // Union by rank\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        return true;  // Union successful\n    }\n    \n    public boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n}",
      "javascript": "class DSU {\n    constructor(n) {\n        this.parent = Array.from({length: n}, (_, i) => i);\n        this.rank = Array(n).fill(0);\n    }\n    \n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);  // Path compression\n        }\n        return this.parent[x];\n    }\n    \n    union(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        \n        if (rootX === rootY) {\n            return false;  // Already in same set\n        }\n        \n        // Union by rank\n        if (this.rank[rootX] < this.rank[rootY]) {\n            this.parent[rootX] = rootY;\n        } else if (this.rank[rootX] > this.rank[rootY]) {\n            this.parent[rootY] = rootX;\n        } else {\n            this.parent[rootY] = rootX;\n            this.rank[rootX]++;\n        }\n        \n        return true;  // Union successful\n    }\n    \n    connected(x, y) {\n        return this.find(x) === this.find(y);\n    }\n}",
      "rust": "pub struct DSU {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl DSU {\n    pub fn new(n: usize) -> Self {\n        Self {\n            parent: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n    \n    pub fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] != x {\n            self.parent[x] = self.find(self.parent[x]);  // Path compression\n        }\n        self.parent[x]\n    }\n    \n    pub fn union(&mut self, x: usize, y: usize) -> bool {\n        let root_x = self.find(x);\n        let root_y = self.find(y);\n        \n        if root_x == root_y {\n            return false;  // Already in same set\n        }\n        \n        // Union by rank\n        if self.rank[root_x] < self.rank[root_y] {\n            self.parent[root_x] = root_y;\n        } else if self.rank[root_x] > self.rank[root_y] {\n            self.parent[root_y] = root_x;\n        } else {\n            self.parent[root_y] = root_x;\n            self.rank[root_x] += 1;\n        }\n        \n        true  // Union successful\n    }\n    \n    pub fn connected(&mut self, x: usize, y: usize) -> bool {\n        self.find(x) == self.find(y)\n    }\n}",
      "kotlin": "class DSU(n: Int) {\n    private val parent = IntArray(n) { it }\n    private val rank = IntArray(n)\n    \n    fun find(x: Int): Int {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x])  // Path compression\n        }\n        return parent[x]\n    }\n    \n    fun union(x: Int, y: Int): Boolean {\n        val rootX = find(x)\n        val rootY = find(y)\n        \n        if (rootX == rootY) {\n            return false  // Already in same set\n        }\n        \n        // Union by rank\n        when {\n            rank[rootX] < rank[rootY] -> {\n                parent[rootX] = rootY\n            }\n            rank[rootX] > rank[rootY] -> {\n                parent[rootY] = rootX\n            }\n            else -> {\n                parent[rootY] = rootX\n                rank[rootX]++\n            }\n        }\n        \n        return true  // Union successful\n    }\n    \n    fun connected(x: Int, y: Int): Boolean {\n        return find(x) == find(y)\n    }\n}"
    },
    "tags": ["disjoint-set","union-find"]
  },
  {
    "id": "algo-knapsack01",
    "topic": "0-1 Knapsack (DP)",
    "category": "Dynamic Programming",
    "description": "Maximizes value without exceeding weight; each item chosen at most once.",
    "time_complexity": { "best": "O(nW)", "average": "O(nW)", "worst": "O(nW)" },
    "space_complexity": "O(nW)",
    "pseudo_code": "dp[i][w] = max(dp[i-1][w], val[i] + dp[i-1][w - wt[i]]) if wt[i] <= w else dp[i-1][w]",
    "visualization": {
      "type": "table",
      "description": "Displays DP table filling row by row, highlights chosen cells.",
      "example_steps": [
        "Initialize row 0",
        "Fill row i with max of include/exclude",
        "Result in dp[n][W]"
      ]
    },
    "code": {
      "python": "def knapsack(vals, wts, W):\n    n = len(vals)\n    # dp[i][w] = maximum value using first i items with weight limit w\n    dp = [ * (W + 1) for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for w in range(W + 1):\n            # Current item index in original arrays\n            curr_weight = wts[i - 1]\n            curr_value = vals[i - 1]\n            \n            if curr_weight <= w:\n                # We can include this item\n                include_value = curr_value + dp[i - 1][w - curr_weight]\n                exclude_value = dp[i - 1][w]\n                dp[i][w] = max(include_value, exclude_value)\n            else:\n                # We cannot include this item\n                dp[i][w] = dp[i - 1][w]\n    \n    return dp[n][W]\n\n# Space optimized version (1D array)\ndef knapsack_optimized(vals, wts, W):\n    n = len(vals)\n    dp =  * (W + 1)\n    \n    for i in range(n):\n        # Traverse from right to left to avoid using updated values\n        for w in range(W, wts[i] - 1, -1):\n            dp[w] = max(dp[w], vals[i] + dp[w - wts[i]])\n    \n    return dp[W]",
      "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint knapsack(const vector<int>& vals, const vector<int>& wts, int W) {\n    int n = vals.size();\n    // dp[i][w] = maximum value using first i items with weight limit w\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));\n    \n    // Fill the DP table\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            int currWeight = wts[i - 1];\n            int currValue = vals[i - 1];\n            \n            if (currWeight <= w) {\n                // We can include this item\n                int includeValue = currValue + dp[i - 1][w - currWeight];\n                int excludeValue = dp[i - 1][w];\n                dp[i][w] = max(includeValue, excludeValue);\n            } else {\n                // We cannot include this item\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    \n    return dp[n][W];\n}\n\n// Space optimized version\nint knapsackOptimized(const vector<int>& vals, const vector<int>& wts, int W) {\n    vector<int> dp(W + 1, 0);\n    \n    for (int i = 0; i < vals.size(); i++) {\n        // Traverse from right to left\n        for (int w = W; w >= wts[i]; w--) {\n            dp[w] = max(dp[w], vals[i] + dp[w - wts[i]]);\n        }\n    }\n    \n    return dp[W];\n}",
      "java": "public static int knapsack(int[] vals, int[] wts, int W) {\n    int n = vals.length;\n    // dp[i][w] = maximum value using first i items with weight limit w\n    int[][] dp = new int[n + 1][W + 1];\n    \n    // Fill the DP table\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            int currWeight = wts[i - 1];\n            int currValue = vals[i - 1];\n            \n            if (currWeight <= w) {\n                // We can include this item\n                int includeValue = currValue + dp[i - 1][w - currWeight];\n                int excludeValue = dp[i - 1][w];\n                dp[i][w] = Math.max(includeValue, excludeValue);\n            } else {\n                // We cannot include this item\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    \n    return dp[n][W];\n}\n\n// Space optimized version\npublic static int knapsackOptimized(int[] vals, int[] wts, int W) {\n    int[] dp = new int[W + 1];\n    \n    for (int i = 0; i < vals.length; i++) {\n        // Traverse from right to left\n        for (int w = W; w >= wts[i]; w--) {\n            dp[w] = Math.max(dp[w], vals[i] + dp[w - wts[i]]);\n        }\n    }\n    \n    return dp[W];\n}",
      "javascript": "function knapsack(vals, wts, W) {\n    const n = vals.length;\n    // dp[i][w] = maximum value using first i items with weight limit w\n    const dp = Array.from({length: n + 1}, () => Array(W + 1).fill(0));\n    \n    // Fill the DP table\n    for (let i = 1; i <= n; i++) {\n        for (let w = 0; w <= W; w++) {\n            const currWeight = wts[i - 1];\n            const currValue = vals[i - 1];\n            \n            if (currWeight <= w) {\n                // We can include this item\n                const includeValue = currValue + dp[i - 1][w - currWeight];\n                const excludeValue = dp[i - 1][w];\n                dp[i][w] = Math.max(includeValue, excludeValue);\n            } else {\n                // We cannot include this item\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    \n    return dp[n][W];\n}\n\n// Space optimized version\nfunction knapsackOptimized(vals, wts, W) {\n    const dp = Array(W + 1).fill(0);\n    \n    for (let i = 0; i < vals.length; i++) {\n        // Traverse from right to left\n        for (let w = W; w >= wts[i]; w--) {\n            dp[w] = Math.max(dp[w], vals[i] + dp[w - wts[i]]);\n        }\n    }\n    \n    return dp[W];\n}",
      "rust": "pub fn knapsack(vals: &Vec<i32>, wts: &Vec<i32>, W: usize) -> i32 {\n    let n = vals.len();\n    // dp[i][w] = maximum value using first i items with weight limit w\n    let mut dp = vec![vec![0; W + 1]; n + 1];\n    \n    // Fill the DP table\n    for i in 1..=n {\n        for w in 0..=W {\n            let curr_weight = wts[i - 1] as usize;\n            let curr_value = vals[i - 1];\n            \n            if curr_weight <= w {\n                // We can include this item\n                let include_value = curr_value + dp[i - 1][w - curr_weight];\n                let exclude_value = dp[i - 1][w];\n                dp[i][w] = include_value.max(exclude_value);\n            } else {\n                // We cannot include this item\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    \n    dp[n][W]\n}\n\n// Space optimized version\npub fn knapsack_optimized(vals: &Vec<i32>, wts: &Vec<i32>, W: usize) -> i32 {\n    let mut dp = vec![0; W + 1];\n    \n    for i in 0..vals.len() {\n        let curr_weight = wts[i] as usize;\n        // Traverse from right to left\n        for w in (curr_weight..=W).rev() {\n            dp[w] = dp[w].max(vals[i] + dp[w - curr_weight]);\n        }\n    }\n    \n    dp[W]\n}",
      "kotlin": "fun knapsack(vals: IntArray, wts: IntArray, W: Int): Int {\n    val n = vals.size\n    // dp[i][w] = maximum value using first i items with weight limit w\n    val dp = Array(n + 1) { IntArray(W + 1) }\n    \n    // Fill the DP table\n    for (i in 1..n) {\n        for (w in 0..W) {\n            val currWeight = wts[i - 1]\n            val currValue = vals[i - 1]\n            \n            dp[i][w] = if (currWeight <= w) {\n                // We can include this item\n                val includeValue = currValue + dp[i - 1][w - currWeight]\n                val excludeValue = dp[i - 1][w]\n                maxOf(includeValue, excludeValue)\n            } else {\n                // We cannot include this item\n                dp[i - 1][w]\n            }\n        }\n    }\n    \n    return dp[n][W]\n}\n\n// Space optimized version\nfun knapsackOptimized(vals: IntArray, wts: IntArray, W: Int): Int {\n    val dp = IntArray(W + 1)\n    \n    for (i in vals.indices) {\n        // Traverse from right to left\n        for (w in W downTo wts[i]) {\n            dp[w] = maxOf(dp[w], vals[i] + dp[w - wts[i]])\n        }\n    }\n    \n    return dp[W]\n}"
    },
    "tags": ["dp","optimization"]
  },
  {
    "id": "algo-recursion-factorial",
    "topic": "Factorial (Recursion)",
    "category": "Recursion",
    "description": "Computes n! recursively.",
    "time_complexity": { "best": "O(n)", "average": "O(n)", "worst": "O(n)" },
    "space_complexity": "O(n)",
    "pseudo_code": "fact(n): if n <= 1: return 1 else: return n * fact(n-1)",
    "visualization": {
      "type": "call_stack",
      "description": "Shows recursive calls stacking and returning.",
      "example_steps": [
        "fact(4) → fact(3) → fact(2) → fact(1)",
        "Return and multiply"
      ]
    },
    "code": {
      "python": "def factorial(n):\n    \"\"\"\n    Calculate factorial of n using recursion\n    \n    Args:\n        n: Non-negative integer\n    \n    Returns:\n        n! (factorial of n)\n    \"\"\"\n    # Base case\n    if n <= 1:\n        return 1\n    \n    # Recursive case\n    return n * factorial(n - 1)\n\n# Iterative version (more efficient)\ndef factorial_iterative(n):\n    \"\"\"\n    Calculate factorial of n using iteration\n    \n    Args:\n        n: Non-negative integer\n    \n    Returns:\n        n! (factorial of n)\n    \"\"\"\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\n# Memoized recursive version\ndef factorial_memo(n, memo={}):\n    \"\"\"\n    Calculate factorial of n using memoization\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        return 1\n    \n    memo[n] = n * factorial_memo(n - 1, memo)\n    return memo[n]",
      "cpp": "#include <iostream>\nusing namespace std;\n\n// Recursive factorial\nlong long factorial(long long n) {\n    // Base case\n    if (n <= 1) {\n        return 1;\n    }\n    \n    // Recursive case\n    return n * factorial(n - 1);\n}\n\n// Iterative factorial (more efficient)\nlong long factorialIterative(long long n) {\n    long long result = 1;\n    for (long long i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Tail recursive factorial\nlong long factorialTailRec(long long n, long long acc = 1) {\n    if (n <= 1) {\n        return acc;\n    }\n    return factorialTailRec(n - 1, n * acc);\n}",
      "java": "public class Factorial {\n    \n    // Recursive factorial\n    public static long factorial(long n) {\n        // Base case\n        if (n <= 1) {\n            return 1;\n        }\n        \n        // Recursive case\n        return n * factorial(n - 1);\n    }\n    \n    // Iterative factorial (more efficient)\n    public static long factorialIterative(long n) {\n        long result = 1;\n        for (long i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n    \n    // Memoized factorial using array\n    private static long[] memo = new long; // For n <= 20\n    \n    public static long factorialMemo(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        \n        if (memo[n] != 0) {\n            return memo[n];\n        }\n        \n        memo[n] = n * factorialMemo(n - 1);\n        return memo[n];\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(factorial(5)); // Output: 120\n        System.out.println(factorialIterative(5)); // Output: 120\n    }\n}",
      "javascript": "// Recursive factorial\nfunction factorial(n) {\n    // Base case\n    if (n <= 1) {\n        return 1;\n    }\n    \n    // Recursive case\n    return n * factorial(n - 1);\n}\n\n// Iterative factorial (more efficient)\nfunction factorialIterative(n) {\n    let result = 1;\n    for (let i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Memoized factorial\nconst factorialMemo = (function() {\n    const memo = {};\n    \n    return function(n) {\n        if (n in memo) {\n            return memo[n];\n        }\n        \n        if (n <= 1) {\n            return 1;\n        }\n        \n        memo[n] = n * factorialMemo(n - 1);\n        return memo[n];\n    };\n})();\n\n// Arrow function version\nconst factorialArrow = (n) => {\n    return n <= 1 ? 1 : n * factorialArrow(n - 1);\n};\n\n// Usage examples\nconsole.log(factorial(5)); // Output: 120\nconsole.log(factorialIterative(5)); // Output: 120",
      "rust": "// Recursive factorial\npub fn factorial(n: u64) -> u64 {\n    // Base case\n    if n <= 1 {\n        1\n    } else {\n        // Recursive case\n        n * factorial(n - 1)\n    }\n}\n\n// Iterative factorial (more efficient)\npub fn factorial_iterative(n: u64) -> u64 {\n    (2..=n).product()\n}\n\n// Alternative iterative implementation\npub fn factorial_iterative_loop(n: u64) -> u64 {\n    let mut result = 1;\n    for i in 2..=n {\n        result *= i;\n    }\n    result\n}\n\n// Tail recursive factorial\npub fn factorial_tail_rec(n: u64) -> u64 {\n    fn helper(n: u64, acc: u64) -> u64 {\n        if n <= 1 {\n            acc\n        } else {\n            helper(n - 1, n * acc)\n        }\n    }\n    helper(n, 1)\n}\n\n// Using match for pattern matching\npub fn factorial_match(n: u64) -> u64 {\n    match n {\n        0 | 1 => 1,\n        _ => n * factorial_match(n - 1),\n    }\n}\n\n// Example usage\nfn main() {\n    println!(\"5! = {}\", factorial(5)); // Output: 120\n    println!(\"5! = {}\", factorial_iterative(5)); // Output: 120\n}",
      "kotlin": "// Recursive factorial\nfun factorial(n: Long): Long {\n    // Base case\n    return if (n <= 1) {\n        1\n    } else {\n        // Recursive case\n        n * factorial(n - 1)\n    }\n}\n\n// One-liner recursive factorial\nfun factorialOneLiner(n: Long): Long = if (n <= 1) 1 else n * factorialOneLiner(n - 1)\n\n// Iterative factorial (more efficient)\nfun factorialIterative(n: Long): Long {\n    var result = 1L\n    for (i in 2..n) {\n        result *= i\n    }\n    return result\n}\n\n// Using fold (functional approach)\nfun factorialFold(n: Long): Long {\n    return (2..n).fold(1L) { acc, i -> acc * i }\n}\n\n// Tail recursive factorial\ntailrec fun factorialTailRec(n: Long, acc: Long = 1): Long {\n    return if (n <= 1) {\n        acc\n    } else {\n        factorialTailRec(n - 1, n * acc)\n    }\n}\n\n// Memoized factorial using a map\nclass FactorialMemo {\n    private val memo = mutableMapOf<Long, Long>()\n    \n    fun factorial(n: Long): Long {\n        if (n <= 1) return 1\n        \n        return memo.getOrPut(n) {\n            n * factorial(n - 1)\n        }\n    }\n}\n\n// Usage examples\nfun main() {\n    println(\"5! = ${factorial(5)}\") // Output: 120\n    println(\"5! = ${factorialIterative(5)}\") // Output: 120\n    println(\"5! = ${factorialTailRec(5)}\") // Output: 120\n    \n    val memoFactorial = FactorialMemo()\n    println(\"5! = ${memoFactorial.factorial(5)}\") // Output: 120\n}"
    },
    "tags": ["recursion","math"]
  },
  {
    "id": "algo-fibonacci-dp",
    "topic": "Fibonacci (Dynamic Programming)",
    "category": "Dynamic Programming",
    "description": "Computes Fibonacci numbers using dynamic programming to avoid redundant calculations.",
    "time_complexity": { "best": "O(n)", "average": "O(n)", "worst": "O(n)" },
    "space_complexity": "O(1)",
    "pseudo_code": "dp = 0, dp = 1\nfor i = 2 to n: dp[i] = dp[i-1] + dp[i-2]\nreturn dp[n]",
    "visualization": {
      "type": "table",
      "description": "Shows DP table being filled bottom-up with Fibonacci values.",
      "example_steps": [
        "dp=0, dp=1",
        "dp=1, dp=2, dp=3",
        "Build up to dp[n]"
      ]
    },
    "code": {
      "python": "def fibonacci(n):\n    \"\"\"\n    Calculate nth Fibonacci number using dynamic programming\n    \n    Args:\n        n: Non-negative integer\n    \n    Returns:\n        nth Fibonacci number\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # Space-optimized approach\n    prev2, prev1 = 0, 1\n    \n    for i in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    \n    return prev1\n\n# Alternative DP table approach\ndef fibonacci_table(n):\n    if n <= 1:\n        return n\n    \n    dp =  * (n + 1)\n    dp = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]",
      "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    long long fibonacci(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        \n        // Space-optimized approach\n        long long prev2 = 0, prev1 = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            long long curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        \n        return prev1;\n    }\n    \n    // Alternative DP table approach\n    long long fibonacciTable(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        \n        vector<long long> dp(n + 1);\n        dp = 0;\n        dp = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        return dp[n];\n    }\n};",
      "java": "public class Solution {\n    \n    public long fibonacci(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        \n        // Space-optimized approach\n        long prev2 = 0, prev1 = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            long curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        \n        return prev1;\n    }\n    \n    // Alternative DP table approach\n    public long fibonacciTable(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        \n        long[] dp = new long[n + 1];\n        dp = 0;\n        dp = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        return dp[n];\n    }\n}",
      "javascript": "function fibonacci(n) {\n    if (n <= 1) {\n        return n;\n    }\n    \n    // Space-optimized approach\n    let prev2 = 0, prev1 = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        const curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    \n    return prev1;\n}\n\n// Alternative DP table approach\nfunction fibonacciTable(n) {\n    if (n <= 1) {\n        return n;\n    }\n    \n    const dp = Array(n + 1).fill(0);\n    dp = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    \n    return dp[n];\n}",
      "rust": "impl Solution {\n    pub fn fibonacci(n: i32) -> u64 {\n        if n <= 1 {\n            return n as u64;\n        }\n        \n        // Space-optimized approach\n        let mut prev2 = 0u64;\n        let mut prev1 = 1u64;\n        \n        for _ in 2..=n {\n            let curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        \n        prev1\n    }\n    \n    // Alternative DP table approach\n    pub fn fibonacci_table(n: i32) -> u64 {\n        if n <= 1 {\n            return n as u64;\n        }\n        \n        let mut dp = vec![0u64; (n + 1) as usize];\n        dp = 1;\n        \n        for i in 2..=n as usize {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        dp[n as usize]\n    }\n}",
      "kotlin": "class Solution {\n    \n    fun fibonacci(n: Int): Long {\n        if (n <= 1) {\n            return n.toLong()\n        }\n        \n        // Space-optimized approach\n        var prev2 = 0L\n        var prev1 = 1L\n        \n        for (i in 2..n) {\n            val curr = prev1 + prev2\n            prev2 = prev1\n            prev1 = curr\n        }\n        \n        return prev1\n    }\n    \n    // Alternative DP table approach\n    fun fibonacciTable(n: Int): Long {\n        if (n <= 1) {\n            return n.toLong()\n        }\n        \n        val dp = LongArray(n + 1)\n        dp = 0\n        dp = 1\n        \n        for (i in 2..n) {\n            dp[i] = dp[i - 1] + dp[i - 2]\n        }\n        \n        return dp[n]\n    }\n}"
    },
    "tags": ["dp", "sequence", "optimization"]
  },
  {
    "id": "tree-bst-operations",
    "topic": "Binary Search Tree Operations",
    "category": "Tree",
    "description": "Insert, search, and delete operations in a Binary Search Tree.",
    "time_complexity": { "best": "O(log n)", "average": "O(log n)", "worst": "O(n)" },
    "space_complexity": "O(h)",
    "pseudo_code": "search(root, key): if !root or root.val == key: return root\nif key < root.val: return search(root.left, key)\nelse: return search(root.right, key)",
    "visualization": {
      "type": "tree",
      "description": "Shows BST structure and path traversal during operations.",
      "example_steps": [
        "Search: compare with root, go left/right",
        "Insert: find position and add node",
        "Delete: handle 3 cases"
      ]
    },
    "code": {
      "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def search(self, root, key):\n        \"\"\"\n        Search for a key in BST\n        \n        Args:\n            root: TreeNode - root of BST\n            key: int - key to search for\n        \n        Returns:\n            TreeNode or None\n        \"\"\"\n        if not root or root.val == key:\n            return root\n        \n        if key < root.val:\n            return self.search(root.left, key)\n        else:\n            return self.search(root.right, key)\n    \n    def insert(self, root, key):\n        \"\"\"\n        Insert a key into BST\n        \n        Args:\n            root: TreeNode - root of BST\n            key: int - key to insert\n        \n        Returns:\n            TreeNode - new root\n        \"\"\"\n        if not root:\n            return TreeNode(key)\n        \n        if key < root.val:\n            root.left = self.insert(root.left, key)\n        elif key > root.val:\n            root.right = self.insert(root.right, key)\n        \n        return root\n    \n    def delete(self, root, key):\n        \"\"\"\n        Delete a key from BST\n        \n        Args:\n            root: TreeNode - root of BST\n            key: int - key to delete\n        \n        Returns:\n            TreeNode - new root\n        \"\"\"\n        if not root:\n            return root\n        \n        if key < root.val:\n            root.left = self.delete(root.left, key)\n        elif key > root.val:\n            root.right = self.delete(root.right, key)\n        else:\n            # Node to be deleted found\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            \n            # Node with two children\n            min_node = self.find_min(root.right)\n            root.val = min_node.val\n            root.right = self.delete(root.right, min_node.val)\n        \n        return root\n    \n    def find_min(self, root):\n        \"\"\"Find minimum node in BST\"\"\"\n        while root.left:\n            root = root.left\n        return root",
      "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    \n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass BST {\npublic:\n    TreeNode* search(TreeNode* root, int key) {\n        if (!root || root->val == key) {\n            return root;\n        }\n        \n        if (key < root->val) {\n            return search(root->left, key);\n        } else {\n            return search(root->right, key);\n        }\n    }\n    \n    TreeNode* insert(TreeNode* root, int key) {\n        if (!root) {\n            return new TreeNode(key);\n        }\n        \n        if (key < root->val) {\n            root->left = insert(root->left, key);\n        } else if (key > root->val) {\n            root->right = insert(root->right, key);\n        }\n        \n        return root;\n    }\n    \n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (!root) {\n            return root;\n        }\n        \n        if (key < root->val) {\n            root->left = deleteNode(root->left, key);\n        } else if (key > root->val) {\n            root->right = deleteNode(root->right, key);\n        } else {\n            // Node to be deleted found\n            if (!root->left) {\n                TreeNode* temp = root->right;\n                delete root;\n                return temp;\n            } else if (!root->right) {\n                TreeNode* temp = root->left;\n                delete root;\n                return temp;\n            }\n            \n            // Node with two children\n            TreeNode* minNode = findMin(root->right);\n            root->val = minNode->val;\n            root->right = deleteNode(root->right, minNode->val);\n        }\n        \n        return root;\n    }\n    \nprivate:\n    TreeNode* findMin(TreeNode* root) {\n        while (root->left) {\n            root = root->left;\n        }\n        return root;\n    }\n};",
      "java": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\npublic class BST {\n    \n    public TreeNode search(TreeNode root, int key) {\n        if (root == null || root.val == key) {\n            return root;\n        }\n        \n        if (key < root.val) {\n            return search(root.left, key);\n        } else {\n            return search(root.right, key);\n        }\n    }\n    \n    public TreeNode insert(TreeNode root, int key) {\n        if (root == null) {\n            return new TreeNode(key);\n        }\n        \n        if (key < root.val) {\n            root.left = insert(root.left, key);\n        } else if (key > root.val) {\n            root.right = insert(root.right, key);\n        }\n        \n        return root;\n    }\n    \n    public TreeNode delete(TreeNode root, int key) {\n        if (root == null) {\n            return root;\n        }\n        \n        if (key < root.val) {\n            root.left = delete(root.left, key);\n        } else if (key > root.val) {\n            root.right = delete(root.right, key);\n        } else {\n            // Node to be deleted found\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            \n            // Node with two children\n            TreeNode minNode = findMin(root.right);\n            root.val = minNode.val;\n            root.right = delete(root.right, minNode.val);\n        }\n        \n        return root;\n    }\n    \n    private TreeNode findMin(TreeNode root) {\n        while (root.left != null) {\n            root = root.left;\n        }\n        return root;\n    }\n}",
      "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass BST {\n    search(root, key) {\n        if (!root || root.val === key) {\n            return root;\n        }\n        \n        if (key < root.val) {\n            return this.search(root.left, key);\n        } else {\n            return this.search(root.right, key);\n        }\n    }\n    \n    insert(root, key) {\n        if (!root) {\n            return new TreeNode(key);\n        }\n        \n        if (key < root.val) {\n            root.left = this.insert(root.left, key);\n        } else if (key > root.val) {\n            root.right = this.insert(root.right, key);\n        }\n        \n        return root;\n    }\n    \n    delete(root, key) {\n        if (!root) {\n            return root;\n        }\n        \n        if (key < root.val) {\n            root.left = this.delete(root.left, key);\n        } else if (key > root.val) {\n            root.right = this.delete(root.right, key);\n        } else {\n            // Node to be deleted found\n            if (!root.left) {\n                return root.right;\n            } else if (!root.right) {\n                return root.left;\n            }\n            \n            // Node with two children\n            const minNode = this.findMin(root.right);\n            root.val = minNode.val;\n            root.right = this.delete(root.right, minNode.val);\n        }\n        \n        return root;\n    }\n    \n    findMin(root) {\n        while (root.left) {\n            root = root.left;\n        }\n        return root;\n    }\n}",
      "rust": "#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Box<TreeNode>>,\n    pub right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn search_bst(root: Option<Box<TreeNode>>, val: i32) -> Option<Box<TreeNode>> {\n        match root {\n            Some(node) => {\n                if node.val == val {\n                    Some(node)\n                } else if val < node.val {\n                    Self::search_bst(node.left, val)\n                } else {\n                    Self::search_bst(node.right, val)\n                }\n            }\n            None => None,\n        }\n    }\n    \n    pub fn insert_into_bst(root: Option<Box<TreeNode>>, val: i32) -> Option<Box<TreeNode>> {\n        match root {\n            Some(mut node) => {\n                if val < node.val {\n                    node.left = Self::insert_into_bst(node.left, val);\n                } else if val > node.val {\n                    node.right = Self::insert_into_bst(node.right, val);\n                }\n                Some(node)\n            }\n            None => Some(Box::new(TreeNode::new(val))),\n        }\n    }\n    \n    pub fn delete_node(root: Option<Box<TreeNode>>, key: i32) -> Option<Box<TreeNode>> {\n        match root {\n            Some(mut node) => {\n                if key < node.val {\n                    node.left = Self::delete_node(node.left, key);\n                    Some(node)\n                } else if key > node.val {\n                    node.right = Self::delete_node(node.right, key);\n                    Some(node)\n                } else {\n                    // Node to be deleted found\n                    match (node.left.take(), node.right.take()) {\n                        (None, None) => None,\n                        (Some(left), None) => Some(left),\n                        (None, Some(right)) => Some(right),\n                        (Some(left), Some(right)) => {\n                            let min_val = Self::find_min(&right);\n                            node.val = min_val;\n                            node.left = Some(left);\n                            node.right = Self::delete_node(Some(right), min_val);\n                            Some(node)\n                        }\n                    }\n                }\n            }\n            None => None,\n        }\n    }\n    \n    fn find_min(root: &Box<TreeNode>) -> i32 {\n        let mut curr = root;\n        while let Some(ref left) = curr.left {\n            curr = left;\n        }\n        curr.val\n    }\n}",
      "kotlin": "class TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n}\n\nclass BST {\n    \n    fun search(root: TreeNode?, key: Int): TreeNode? {\n        if (root == null || root.`val` == key) {\n            return root\n        }\n        \n        return if (key < root.`val`) {\n            search(root.left, key)\n        } else {\n            search(root.right, key)\n        }\n    }\n    \n    fun insert(root: TreeNode?, key: Int): TreeNode? {\n        if (root == null) {\n            return TreeNode(key)\n        }\n        \n        when {\n            key < root.`val` -> root.left = insert(root.left, key)\n            key > root.`val` -> root.right = insert(root.right, key)\n        }\n        \n        return root\n    }\n    \n    fun delete(root: TreeNode?, key: Int): TreeNode? {\n        if (root == null) {\n            return root\n        }\n        \n        when {\n            key < root.`val` -> root.left = delete(root.left, key)\n            key > root.`val` -> root.right = delete(root.right, key)\n            else -> {\n                // Node to be deleted found\n                when {\n                    root.left == null -> return root.right\n                    root.right == null -> return root.left\n                    else -> {\n                        // Node with two children\n                        val minNode = findMin(root.right!!)\n                        root.`val` = minNode.`val`\n                        root.right = delete(root.right, minNode.`val`)\n                    }\n                }\n            }\n        }\n        \n        return root\n    }\n    \n    private fun findMin(root: TreeNode): TreeNode {\n        var current = root\n        while (current.left != null) {\n            current = current.left!!\n        }\n        return current\n    }\n}"
    },
    "tags": ["bst", "tree", "recursion"]
  },
  {
    "id": "algo-lcs",
    "topic": "Longest Common Subsequence (LCS)",
    "category": "Dynamic Programming",
    "description": "Finds the longest common subsequence between two strings using dynamic programming.",
    "time_complexity": { "best": "O(mn)", "average": "O(mn)", "worst": "O(mn)" },
    "space_complexity": "O(mn)",
    "pseudo_code": "if s1[i] == s2[j]: dp[i][j] = 1 + dp[i-1][j-1]\nelse: dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
    "visualization": {
      "type": "table",
      "description": "Shows DP table filling with LCS lengths, highlights optimal path.",
      "example_steps": [
        "Compare characters",
        "Fill DP table row by row",
        "Backtrack to find LCS"
      ]
    },
    "code": {
      "python": "def longest_common_subsequence(text1, text2):\n    \"\"\"\n    Find the length of longest common subsequence\n    \n    Args:\n        text1: str - first string\n        text2: str - second string\n    \n    Returns:\n        int - length of LCS\n    \"\"\"\n    m, n = len(text1), len(text2)\n    \n    # Create DP table\n    dp = [ * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\ndef lcs_string(text1, text2):\n    \"\"\"\n    Find the actual LCS string\n    \n    Args:\n        text1: str - first string\n        text2: str - second string\n    \n    Returns:\n        str - the LCS string\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [ * (n + 1) for _ in range(m + 1)]\n    \n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # Backtrack to find LCS string\n    lcs = []\n    i, j = m, n\n    \n    while i > 0 and j > 0:\n        if text1[i - 1] == text2[j - 1]:\n            lcs.append(text1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))",
      "cpp": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        // Create DP table\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    string lcsString(string text1, string text2) {\n        int m = text1.length();\n        int n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        // Backtrack to find LCS string\n        string lcs = \"\";\n        int i = m, j = n;\n        \n        while (i > 0 && j > 0) {\n            if (text1[i - 1] == text2[j - 1]) {\n                lcs = text1[i - 1] + lcs;\n                i--;\n                j--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        return lcs;\n    }\n};",
      "java": "public class Solution {\n    \n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        // Create DP table\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    public String lcsString(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        // Backtrack to find LCS string\n        StringBuilder lcs = new StringBuilder();\n        int i = m, j = n;\n        \n        while (i > 0 && j > 0) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                lcs.append(text1.charAt(i - 1));\n                i--;\n                j--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        return lcs.reverse().toString();\n    }\n}",
      "javascript": "function longestCommonSubsequence(text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    \n    // Create DP table\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n    \n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\nfunction lcsString(text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n    \n    // Fill DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    // Backtrack to find LCS string\n    let lcs = '';\n    let i = m, j = n;\n    \n    while (i > 0 && j > 0) {\n        if (text1[i - 1] === text2[j - 1]) {\n            lcs = text1[i - 1] + lcs;\n            i--;\n            j--;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            i--;\n        } else {\n            j--;\n        }\n    }\n    \n    return lcs;\n}",
      "rust": "impl Solution {\n    pub fn longest_common_subsequence(text1: String, text2: String) -> i32 {\n        let text1_chars: Vec<char> = text1.chars().collect();\n        let text2_chars: Vec<char> = text2.chars().collect();\n        let m = text1_chars.len();\n        let n = text2_chars.len();\n        \n        // Create DP table\n        let mut dp = vec![vec![0; n + 1]; m + 1];\n        \n        // Fill the DP table\n        for i in 1..=m {\n            for j in 1..=n {\n                if text1_chars[i - 1] == text2_chars[j - 1] {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);\n                }\n            }\n        }\n        \n        dp[m][n]\n    }\n    \n    pub fn lcs_string(text1: String, text2: String) -> String {\n        let text1_chars: Vec<char> = text1.chars().collect();\n        let text2_chars: Vec<char> = text2.chars().collect();\n        let m = text1_chars.len();\n        let n = text2_chars.len();\n        let mut dp = vec![vec![0; n + 1]; m + 1];\n        \n        // Fill DP table\n        for i in 1..=m {\n            for j in 1..=n {\n                if text1_chars[i - 1] == text2_chars[j - 1] {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);\n                }\n            }\n        }\n        \n        // Backtrack to find LCS string\n        let mut lcs = Vec::new();\n        let (mut i, mut j) = (m, n);\n        \n        while i > 0 && j > 0 {\n            if text1_chars[i - 1] == text2_chars[j - 1] {\n                lcs.push(text1_chars[i - 1]);\n                i -= 1;\n                j -= 1;\n            } else if dp[i - 1][j] > dp[i][j - 1] {\n                i -= 1;\n            } else {\n                j -= 1;\n            }\n        }\n        \n        lcs.reverse();\n        lcs.into_iter().collect()\n    }\n}",
      "kotlin": "class Solution {\n    \n    fun longestCommonSubsequence(text1: String, text2: String): Int {\n        val m = text1.length\n        val n = text2.length\n        \n        // Create DP table\n        val dp = Array(m + 1) { IntArray(n + 1) }\n        \n        // Fill the DP table\n        for (i in 1..m) {\n            for (j in 1..n) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                } else {\n                    dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])\n                }\n            }\n        }\n        \n        return dp[m][n]\n    }\n    \n    fun lcsString(text1: String, text2: String): String {\n        val m = text1.length\n        val n = text2.length\n        val dp = Array(m + 1) { IntArray(n + 1) }\n        \n        // Fill DP table\n        for (i in 1..m) {\n            for (j in 1..n) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                } else {\n                    dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])\n                }\n            }\n        }\n        \n        // Backtrack to find LCS string\n        val lcs = StringBuilder()\n        var i = m\n        var j = n\n        \n        while (i > 0 && j > 0) {\n            when {\n                text1[i - 1] == text2[j - 1] -> {\n                    lcs.append(text1[i - 1])\n                    i--\n                    j--\n                }\n                dp[i - 1][j] > dp[i][j - 1] -> i--\n                else -> j--\n            }\n        }\n        \n        return lcs.reverse().toString()\n    }\n}"
    },
    "tags": ["dp", "string", "subsequence"]
  },
  {
    "id": "algo-edit-distance",
    "topic": "Edit Distance (Levenshtein Distance)",
    "category": "Dynamic Programming",
    "description": "Finds minimum operations (insert, delete, replace) to transform one string into another.",
    "time_complexity": { "best": "O(mn)", "average": "O(mn)", "worst": "O(mn)" },
    "space_complexity": "O(mn)",
    "pseudo_code": "if s1[i] == s2[j]: dp[i][j] = dp[i-1][j-1]\nelse: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])",
    "visualization": {
      "type": "table",
      "description": "Shows DP table with minimum edit distances, highlights operation choices.",
      "example_steps": [
        "Compare characters",
        "Choose min of insert/delete/replace",
        "Fill table bottom-up"
      ]
    },
    "code": {
      "python": "def min_distance(word1, word2):\n    \"\"\"\n    Find minimum edit distance between two strings\n    \n    Args:\n        word1: str - source string\n        word2: str - target string\n    \n    Returns:\n        int - minimum edit distance\n    \"\"\"\n    m, n = len(word1), len(word2)\n    \n    # Create DP table\n    # dp[i][j] = min operations to transform word1[:i] to word2[:j]\n    dp = [ * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize base cases\n    for i in range(m + 1):\n        dp[i] = i  # Delete all characters\n    \n    for j in range(n + 1):\n        dp[j] = j  # Insert all characters\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                # No operation needed\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # Choose minimum of three operations\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      # Delete\n                    dp[i][j - 1],      # Insert\n                    dp[i - 1][j - 1]   # Replace\n                )\n    \n    return dp[m][n]\n\ndef min_distance_space_optimized(word1, word2):\n    \"\"\"\n    Space optimized version using only two rows\n    \"\"\"\n    m, n = len(word1), len(word2)\n    \n    # Use only two rows\n    prev = list(range(n + 1))\n    curr =  * (n + 1)\n    \n    for i in range(1, m + 1):\n        curr = i\n        \n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(\n                    prev[j],       # Delete\n                    curr[j - 1],   # Insert\n                    prev[j - 1]    # Replace\n                )\n        \n        prev, curr = curr, prev\n    \n    return prev[n]",
      "cpp": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length();\n        int n = word2.length();\n        \n        // Create DP table\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        \n        // Initialize base cases\n        for (int i = 0; i <= m; i++) {\n            dp[i] = i;  // Delete all characters\n        }\n        \n        for (int j = 0; j <= n; j++) {\n            dp[j] = j;  // Insert all characters\n        }\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    // No operation needed\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    // Choose minimum of three operations\n                    dp[i][j] = 1 + min({\n                        dp[i - 1][j],      // Delete\n                        dp[i][j - 1],      // Insert\n                        dp[i - 1][j - 1]   // Replace\n                    });\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    // Space optimized version\n    int minDistanceOptimized(string word1, string word2) {\n        int m = word1.length();\n        int n = word2.length();\n        \n        vector<int> prev(n + 1);\n        vector<int> curr(n + 1);\n        \n        // Initialize first row\n        for (int j = 0; j <= n; j++) {\n            prev[j] = j;\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            curr = i;\n            \n            for (int j = 1; j <= n; j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    curr[j] = prev[j - 1];\n                } else {\n                    curr[j] = 1 + min({\n                        prev[j],       // Delete\n                        curr[j - 1],   // Insert\n                        prev[j - 1]    // Replace\n                    });\n                }\n            }\n            \n            prev = curr;\n        }\n        \n        return prev[n];\n    }\n};",
      "java": "public class Solution {\n    \n    public int minDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        \n        // Create DP table\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Initialize base cases\n        for (int i = 0; i <= m; i++) {\n            dp[i] = i;  // Delete all characters\n        }\n        \n        for (int j = 0; j <= n; j++) {\n            dp[j] = j;  // Insert all characters\n        }\n        \n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    // No operation needed\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    // Choose minimum of three operations\n                    dp[i][j] = 1 + Math.min(\n                        Math.min(dp[i - 1][j], dp[i][j - 1]),  // Delete, Insert\n                        dp[i - 1][j - 1]                        // Replace\n                    );\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    // Space optimized version\n    public int minDistanceOptimized(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        \n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        // Initialize first row\n        for (int j = 0; j <= n; j++) {\n            prev[j] = j;\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            curr = i;\n            \n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    curr[j] = prev[j - 1];\n                } else {\n                    curr[j] = 1 + Math.min(\n                        Math.min(prev[j], curr[j - 1]),\n                        prev[j - 1]\n                    );\n                }\n            }\n            \n            // Swap arrays\n            int[] temp = prev;\n            prev = curr;\n            curr = temp;\n        }\n        \n        return prev[n];\n    }\n}",
      "javascript": "function minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    \n    // Create DP table\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n    \n    // Initialize base cases\n    for (let i = 0; i <= m; i++) {\n        dp[i] = i;  // Delete all characters\n    }\n    \n    for (let j = 0; j <= n; j++) {\n        dp[j] = j;  // Insert all characters\n    }\n    \n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                // No operation needed\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Choose minimum of three operations\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],      // Delete\n                    dp[i][j - 1],      // Insert\n                    dp[i - 1][j - 1]   // Replace\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\n// Space optimized version\nfunction minDistanceOptimized(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    \n    let prev = Array.from({length: n + 1}, (_, i) => i);\n    let curr = Array(n + 1).fill(0);\n    \n    for (let i = 1; i <= m; i++) {\n        curr = i;\n        \n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                curr[j] = prev[j - 1];\n            } else {\n                curr[j] = 1 + Math.min(\n                    prev[j],       // Delete\n                    curr[j - 1],   // Insert\n                    prev[j - 1]    // Replace\n                );\n            }\n        }\n        \n        [prev, curr] = [curr, prev];\n    }\n    \n    return prev[n];\n}",
      "rust": "impl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        let word1_chars: Vec<char> = word1.chars().collect();\n        let word2_chars: Vec<char> = word2.chars().collect();\n        let m = word1_chars.len();\n        let n = word2_chars.len();\n        \n        // Create DP table\n        let mut dp = vec![vec![0; n + 1]; m + 1];\n        \n        // Initialize base cases\n        for i in 0..=m {\n            dp[i] = i as i32;  // Delete all characters\n        }\n        \n        for j in 0..=n {\n            dp[j] = j as i32;  // Insert all characters\n        }\n        \n        // Fill the DP table\n        for i in 1..=m {\n            for j in 1..=n {\n                if word1_chars[i - 1] == word2_chars[j - 1] {\n                    // No operation needed\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    // Choose minimum of three operations\n                    dp[i][j] = 1 + dp[i - 1][j]        // Delete\n                        .min(dp[i][j - 1])             // Insert\n                        .min(dp[i - 1][j - 1]);        // Replace\n                }\n            }\n        }\n        \n        dp[m][n]\n    }\n    \n    // Space optimized version\n    pub fn min_distance_optimized(word1: String, word2: String) -> i32 {\n        let word1_chars: Vec<char> = word1.chars().collect();\n        let word2_chars: Vec<char> = word2.chars().collect();\n        let m = word1_chars.len();\n        let n = word2_chars.len();\n        \n        let mut prev: Vec<i32> = (0..=n as i32).collect();\n        let mut curr = vec![0; n + 1];\n        \n        for i in 1..=m {\n            curr = i as i32;\n            \n            for j in 1..=n {\n                if word1_chars[i - 1] == word2_chars[j - 1] {\n                    curr[j] = prev[j - 1];\n                } else {\n                    curr[j] = 1 + prev[j]        // Delete\n                        .min(curr[j - 1])        // Insert\n                        .min(prev[j - 1]);       // Replace\n                }\n            }\n            \n            std::mem::swap(&mut prev, &mut curr);\n        }\n        \n        prev[n]\n    }\n}",
      "kotlin": "class Solution {\n    \n    fun minDistance(word1: String, word2: String): Int {\n        val m = word1.length\n        val n = word2.length\n        \n        // Create DP table\n        val dp = Array(m + 1) { IntArray(n + 1) }\n        \n        // Initialize base cases\n        for (i in 0..m) {\n            dp[i] = i  // Delete all characters\n        }\n        \n        for (j in 0..n) {\n            dp[j] = j  // Insert all characters\n        }\n        \n        // Fill the DP table\n        for (i in 1..m) {\n            for (j in 1..n) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    // No operation needed\n                    dp[i][j] = dp[i - 1][j - 1]\n                } else {\n                    // Choose minimum of three operations\n                    dp[i][j] = 1 + minOf(\n                        dp[i - 1][j],      // Delete\n                        dp[i][j - 1],      // Insert\n                        dp[i - 1][j - 1]   // Replace\n                    )\n                }\n            }\n        }\n        \n        return dp[m][n]\n    }\n    \n    // Space optimized version\n    fun minDistanceOptimized(word1: String, word2: String): Int {\n        val m = word1.length\n        val n = word2.length\n        \n        var prev = IntArray(n + 1) { it }\n        var curr = IntArray(n + 1)\n        \n        for (i in 1..m) {\n            curr = i\n            \n            for (j in 1..n) {\n                curr[j] = if (word1[i - 1] == word2[j - 1]) {\n                    prev[j - 1]\n                } else {\n                    1 + minOf(\n                        prev[j],       // Delete\n                        curr[j - 1],   // Insert\n                        prev[j - 1]    // Replace\n                    )\n                }\n            }\n            \n            val temp = prev\n            prev = curr\n            curr = temp\n        }\n        \n        return prev[n]\n    }\n}"
    },
    "tags": ["dp", "string", "edit-distance"]
  },
  {
    "id": "algo-two-pointers",
    "topic": "Two Pointers Technique",
    "category": "Array",
    "description": "Uses two pointers to solve problems efficiently, commonly for sorted arrays or strings.",
    "time_complexity": { "best": "O(n)", "average": "O(n)", "worst": "O(n)" },
    "space_complexity": "O(1)",
    "pseudo_code": "left = 0, right = n-1\nwhile left < right:\n  if condition: process and move pointers\n  else: adjust pointers based on problem",
    "visualization": {
      "type": "array",
      "description": "Shows two pointers moving towards each other or in same direction.",
      "example_steps": [
        "Initialize pointers at start/end",
        "Compare values at pointers",
        "Move pointers based on condition"
      ]
    },
    "code": {
      "python": "def two_sum_sorted(numbers, target):\n    \"\"\"\n    Find two numbers in sorted array that sum to target\n    \n    Args:\n        numbers: List[int] - sorted array\n        target: int - target sum\n    \n    Returns:\n        List[int] - indices of two numbers (1-indexed)\n    \"\"\"\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []  # No solution found\n\ndef is_palindrome(s):\n    \"\"\"\n    Check if string is palindrome using two pointers\n    \n    Args:\n        s: str - input string\n    \n    Returns:\n        bool - True if palindrome\n    \"\"\"\n    # Convert to lowercase and keep only alphanumeric\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef three_sum(nums):\n    \"\"\"\n    Find all unique triplets that sum to zero\n    \n    Args:\n        nums: List[int] - input array\n    \n    Returns:\n        List[List[int]] - all unique triplets\n    \"\"\"\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicates for first element\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
      "cpp": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left = 0, right = numbers.size() - 1;\n        \n        while (left < right) {\n            int currentSum = numbers[left] + numbers[right];\n            \n            if (currentSum == target) {\n                return {left + 1, right + 1};  // 1-indexed\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return {};  // No solution found\n    }\n    \n    bool isPalindrome(string s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            // Skip non-alphanumeric characters\n            while (left < right && !isalnum(s[left])) {\n                left++;\n            }\n            while (left < right && !isalnum(s[right])) {\n                right--;\n            }\n            \n            // Compare characters (case insensitive)\n            if (tolower(s[left]) != tolower(s[right])) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> result;\n        \n        for (int i = 0; i < nums.size() - 2; i++) {\n            // Skip duplicates for first element\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            \n            int left = i + 1, right = nums.size() - 1;\n            \n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n                \n                if (currentSum == 0) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) {\n                        left++;\n                    }\n                    while (left < right && nums[right] == nums[right - 1]) {\n                        right--;\n                    }\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
      "java": "import java.util.*;\n\npublic class Solution {\n    \n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0, right = numbers.length - 1;\n        \n        while (left < right) {\n            int currentSum = numbers[left] + numbers[right];\n            \n            if (currentSum == target) {\n                return new int[]{left + 1, right + 1};  // 1-indexed\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return new int[]{};  // No solution found\n    }\n    \n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            // Skip non-alphanumeric characters\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            \n            // Compare characters (case insensitive)\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            // Skip duplicates for first element\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            \n            int left = i + 1, right = nums.length - 1;\n            \n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n                \n                if (currentSum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) {\n                        left++;\n                    }\n                    while (left < right && nums[right] == nums[right - 1]) {\n                        right--;\n                    }\n                    \n                    left++;\n                    right--;\n                } else if (currentSum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
      "javascript": "function twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    \n    while (left < right) {\n        const currentSum = numbers[left] + numbers[right];\n        \n        if (currentSum === target) {\n            return [left + 1, right + 1];  // 1-indexed\n        } else if (currentSum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return [];  // No solution found\n}\n\nfunction isPalindrome(s) {\n    let left = 0, right = s.length - 1;\n    \n    while (left < right) {\n        // Skip non-alphanumeric characters\n        while (left < right && !isAlphaNumeric(s[left])) {\n            left++;\n        }\n        while (left < right && !isAlphaNumeric(s[right])) {\n            right--;\n        }\n        \n        // Compare characters (case insensitive)\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nfunction isAlphaNumeric(char) {\n    return /[a-zA-Z0-9]/.test(char);\n}\n\nfunction threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        // Skip duplicates for first element\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        \n        let left = i + 1, right = nums.length - 1;\n        \n        while (left < right) {\n            const currentSum = nums[i] + nums[left] + nums[right];\n            \n            if (currentSum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                // Skip duplicates\n                while (left < right && nums[left] === nums[left + 1]) {\n                    left++;\n                }\n                while (left < right && nums[right] === nums[right - 1]) {\n                    right--;\n                }\n                \n                left++;\n                right--;\n            } else if (currentSum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}",
      "rust": "impl Solution {\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut left = 0;\n        let mut right = numbers.len() - 1;\n        \n        while left < right {\n            let current_sum = numbers[left] + numbers[right];\n            \n            if current_sum == target {\n                return vec![left as i32 + 1, right as i32 + 1];  // 1-indexed\n            } else if current_sum < target {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n        \n        vec![]  // No solution found\n    }\n    \n    pub fn is_palindrome(s: String) -> bool {\n        let chars: Vec<char> = s.chars().collect();\n        let mut left = 0;\n        let mut right = chars.len();\n        \n        if right == 0 {\n            return true;\n        }\n        \n        right -= 1;\n        \n        while left < right {\n            // Skip non-alphanumeric characters\n            while left < right && !chars[left].is_alphanumeric() {\n                left += 1;\n            }\n            while left < right && !chars[right].is_alphanumeric() {\n                if right == 0 {\n                    break;\n                }\n                right -= 1;\n            }\n            \n            // Compare characters (case insensitive)\n            if chars[left].to_ascii_lowercase() != chars[right].to_ascii_lowercase() {\n                return false;\n            }\n            \n            left += 1;\n            if right == 0 {\n                break;\n            }\n            right -= 1;\n        }\n        \n        true\n    }\n    \n    pub fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        nums.sort();\n        let mut result = Vec::new();\n        \n        for i in 0..nums.len().saturating_sub(2) {\n            // Skip duplicates for first element\n            if i > 0 && nums[i] == nums[i - 1] {\n                continue;\n            }\n            \n            let mut left = i + 1;\n            let mut right = nums.len() - 1;\n            \n            while left < right {\n                let current_sum = nums[i] + nums[left] + nums[right];\n                \n                if current_sum == 0 {\n                    result.push(vec![nums[i], nums[left], nums[right]]);\n                    \n                    // Skip duplicates\n                    while left < right && nums[left] == nums[left + 1] {\n                        left += 1;\n                    }\n                    while left < right && nums[right] == nums[right - 1] {\n                        right -= 1;\n                    }\n                    \n                    left += 1;\n                    right -= 1;\n                } else if current_sum < 0 {\n                    left += 1;\n                } else {\n                    right -= 1;\n                }\n            }\n        }\n        \n        result\n    }\n}",
      "kotlin": "class Solution {\n    \n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        var left = 0\n        var right = numbers.size - 1\n        \n        while (left < right) {\n            val currentSum = numbers[left] + numbers[right]\n            \n            when {\n                currentSum == target -> return intArrayOf(left + 1, right + 1)  // 1-indexed\n                currentSum < target -> left++\n                else -> right--\n            }\n        }\n        \n        return intArrayOf()  // No solution found\n    }\n    \n    fun isPalindrome(s: String): Boolean {\n        var left = 0\n        var right = s.length - 1\n        \n        while (left < right) {\n            // Skip non-alphanumeric characters\n            while (left < right && !s[left].isLetterOrDigit()) {\n                left++\n            }\n            while (left < right && !s[right].isLetterOrDigit()) {\n                right--\n            }\n            \n            // Compare characters (case insensitive)\n            if (s[left].lowercaseChar() != s[right].lowercaseChar()) {\n                return false\n            }\n            \n            left++\n            right--\n        }\n        \n        return true\n    }\n    \n    fun threeSum(nums: IntArray): List<List<Int>> {\n        nums.sort()\n        val result = mutableListOf<List<Int>>()\n        \n        for (i in 0 until nums.size - 2) {\n            // Skip duplicates for first element\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue\n            }\n            \n            var left = i + 1\n            var right = nums.size - 1\n            \n            while (left < right) {\n                val currentSum = nums[i] + nums[left] + nums[right]\n                \n                when {\n                    currentSum == 0 -> {\n                        result.add(listOf(nums[i], nums[left], nums[right]))\n                        \n                        // Skip duplicates\n                        while (left < right && nums[left] == nums[left + 1]) {\n                            left++\n                        }\n                        while (left < right && nums[right] == nums[right - 1]) {\n                            right--\n                        }\n                        \n                        left++\n                        right--\n                    }\n                    currentSum < 0 -> left++\n                    else -> right--\n                }\n            }\n        }\n        \n        return result\n    }\n}"
    },
    "tags": ["two-pointers", "array", "string"]
  }
]
